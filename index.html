<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Triathlon Results Visualizer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* MODIFIED: Consolidated font system with rem units for scalability */
        :root {
            --font-size-xs: 0.75rem;  /* 12px */
            --font-size-sm: 0.875rem; /* 14px */
            --font-size-md: 1rem;     /* 16px */
            --font-size-lg: 1.5rem;   /* 24px */
            --font-weight-normal: 400;
            --font-weight-medium: 500;
            --font-weight-semibold: 600;
            
            /* ADD: Chart dimensions and spacing */
            --chart-width: 100%;
            --chart-min-height: 400px;
            --chart-margin-top: 40px;
            --chart-margin-right: 150px;
            --chart-margin-bottom: 60px;
            --chart-margin-left: 100px;
            
            /* ADD: Common chart colors */
            --grid-color: #e0e0e0;
            --grid-opacity: 0.7;
            --axis-color: #333;
            --label-color: #666;
            
            /* ADD: Athlete visibility states */
            --athlete-opacity-visible: 1;
            --athlete-opacity-hidden: 0.3;
            --athlete-line-width: 1.5;
            --athlete-line-width-hover: 3;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: var(--font-size-md);
            font-weight: var(--font-weight-normal);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 1.25rem;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            padding: 30px;
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 1.875rem;
            font-size: var(--font-size-lg);
            font-weight: var(--font-weight-semibold);
        }

        .upload-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s ease;
        }

        .upload-section.has-data {
            padding: 20px;
            background: #f8f9fa;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            cursor: pointer;
            margin-bottom: 20px;
        }

        .file-input-label {
            display: inline-block;
            padding: 0.75rem 1.875rem;
            background: white;
            color: #667eea;
            border-radius: 3.125rem;
            font-size: var(--font-size-sm);
            font-weight: var(--font-weight-semibold);
            transition: all 0.3s ease;
            cursor: pointer;
            box-shadow: 0 0.25rem 0.9375rem rgba(0,0,0,0.1);
        }

        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
        }

        .file-input-label.has-file {
            background: #28a745;
            color: white;
        }

        input[type="file"] {
            display: none;
        }

        .file-name {
            color: white;
            margin-top: 0.625rem;
            font-size: var(--font-size-sm);
        }

        .has-data .file-name {
            color: #666;
        }

        .chart-container {
            margin: 40px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 15px;
            display: none;
        }

        .chart-container.active {
            display: block;
        }

        /* ADD: Common chart title styling */
        .chart-title {
            font-size: var(--font-size-lg);
            color: var(--axis-color);
            margin-bottom: 1.25rem;
            text-align: center;
            font-weight: var(--font-weight-semibold);
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .btn {
            padding: 0.5rem 1rem;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 0.3125rem;
            cursor: pointer;
            font-size: var(--font-size-sm);
            font-weight: var(--font-weight-medium);
            transition: all 0.3s ease;
            opacity: var(--athlete-opacity-visible);
        }

        .btn:hover {
            background: #5a67d8;
            transform: translateY(-1px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.active {
            background: #4c51bf;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        /* ADD: Hidden state for athlete buttons */
        .btn.hidden {
            opacity: var(--athlete-opacity-hidden);
            background: #a0aec0;
        }

        .btn.toggle-all {
            background: #28a745;
            opacity: var(--athlete-opacity-visible);
        }

        .btn.toggle-all:hover {
            background: #218838;
        }

        .legend-container {
            margin: 20px 0;
            padding: 15px;
            background: white;
            border-radius: 10px;
            max-height: 400px;
            overflow-y: auto;
        }

        .legend-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e0e0e0;
        }
        /* ADD: Collapsible group styles */
        .athlete-group {
            margin-bottom: 10px;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
        }
        .group-header {
            padding: 8px 12px;
            background: #f8f9fa;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            font-size: 13px;
        }
        .group-header:hover {
            background: #e9ecef;
        }
        .group-content {
            padding: 5px;
            display: none;
        }
        .group-content.expanded {
            display: block;
        }
        .group-arrow {
            transition: transform 0.3s;
        }
        .group-header.expanded .group-arrow {
            transform: rotate(90deg);
        }

        .athlete-legend {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e0e0e0;
        }

        .country-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }

        .country-item {
            display: inline-flex;
            align-items: center;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
            border: 1px solid #ddd;
            opacity: var(--athlete-opacity-visible);
        }
        .country-item.selected {
            opacity: 1 !important;
            font-weight: 600;
            box-shadow: 0 0 0 2px currentColor;
        }

        .btn.country-selected {
            opacity: 1 !important;
            font-weight: 600;
        }

        .country-item:hover {
            background: #f0f0f0;
        }

        .country-item.hidden {
            opacity: var(--athlete-opacity-hidden);
            background: #f8f8f8;
        }

        .country-flag {
            margin-right: 1px;
            font-size: 16px;
        }

        .legend-item {
            display: inline-flex;
            align-items: center;
            margin: 5px 15px 5px 0;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 5px;
            transition: all 0.3s ease;
            user-select: none;
            opacity: var(--athlete-opacity-visible);
        }

        .legend-item:hover {
            background: #f0f0f0;
        }

        .legend-item.hidden {
            opacity: var(--athlete-opacity-hidden);
        }

        .legend-color {
            width: 20px;
            height: 3px;
            margin-right: 8px;
            border-radius: 2px;
        }

        .legend-text {
            font-size: var(--font-size-xs);
            color: var(--label-color);
        }

        .tooltip {
            position: absolute;
            text-align: left;
            padding: 10px;
            font-size: var(--font-size-xs);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            border-radius: 5px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
        }

        .error-message {
            color: #dc3545;
            margin-top: 10px;
            padding: 10px;
            background: #f8d7da;
            border-radius: 5px;
            display: none;
        }

        .stats-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
            padding: 20px;
            background: white;
            border-radius: 10px;
        }
        
        @media (max-width: 768px) {
            .stats-summary {
                display: none; /* Hide on mobile to save space */
            }
            
            .finishers-data {
                margin-top: 10px !important;
                padding: 15px !important;
            }
            
            .top-performances {
                margin-top: 20px !important;
            }
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: var(--font-size-lg);
            font-weight: var(--font-weight-semibold);
            color: #667eea;
        }

        .stat-label {
            color: var(--label-color);
            font-size: var(--font-size-sm);
            margin-top: 0.3125rem;
        }

        /* ADD: Common SVG and chart styles */
        svg {
            display: block;
            margin: 0 auto;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            width: var(--chart-width);
            height: auto;
        }
        
        @media (max-width: 768px) {
            svg {
                max-width: 100%;
            }
        }

        /* ADD: Common axis styling */
        .axis text {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: var(--font-size-xs);
            fill: var(--axis-color);
        }

        .axis-label {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: var(--font-size-sm);
            font-weight: var(--font-weight-semibold);
            fill: var(--axis-color);
        }

        /* ADD: Common grid styling */
        .grid line {
            stroke: var(--grid-color);
            stroke-opacity: var(--grid-opacity);
            shape-rendering: crispEdges;
        }

        .grid path {
            stroke-width: 0;
        }

        .athlete-path-hitarea {
            pointer-events: stroke;
            stroke: transparent;
            stroke-width: 10;
        }

        .athlete-path {
            fill: none;
            stroke-width: 1.5;
            opacity: 0.4;
            pointer-events: none;
        }

        .transition-lines line {
            pointer-events: none;
        }

        .athlete-path:hover {
            stroke-width: var(--athlete-line-width-hover);
            opacity: var(--athlete-opacity-visible);
        }

        .athlete-path.hidden {
            display: none;
        }
        .athlete-path-hitarea.hidden {
            display: none;
            pointer-events: none;
        }

        .athlete-line {
            stroke-width: 1.5;
            opacity: 0.4;
            pointer-events: none;  
        }

        .athlete-line-hitarea {
            pointer-events: stroke;
        }

        .athlete-circle {
            opacity: 0.8;
            transition: all 0.3s ease;
        }

        .athlete-circle.hidden {
            display: none;
        }        .radar-area {
            fill-opacity: 0.2;
            stroke-width: 2;
            transition: all 0.3s ease;
        }

        .radar-area:hover {
            fill-opacity: 0.4;
            stroke-width: 3;
        }

        .radar-area.hidden {
            display: none;
        }

        .radar-dots {
            fill-opacity: 0.8;
        }

        .radar-dots.hidden {
            display: none;
        }

        .segment-leader {
            font-size: 11px;
            font-weight: bold;
        }

        .segment-time-label {
            font-size: 10px;
            font-weight: 600;
            fill: var(--label-color);
        }

        /* Hide desktop-only elements by default, show with JS */
        .desktop-only {
            display: none;
        }
        
        @media (max-width: 768px) {
            :root {
                --chart-margin-top: 30px;
                --chart-margin-right: 100px;
                --chart-margin-bottom: 50px;
                --chart-margin-left: 50px;
            }
            
            .container {
                padding: 20px;
            }

            h1 {
                font-size: 1.8em;
            }

            .controls {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }
            
            /* Ensure desktop-only stays hidden on mobile */
            .desktop-only {
                display: none !important;
            }
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .tab-navigation {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 30px 0 20px 0;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
            flex-wrap: wrap;
        }

        .tab-btn {
            padding: 10px 20px;
            background: transparent;
            color: #666;
            border: none;
            border-radius: 5px 5px 0 0;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .tab-btn:hover {
            background: #f0f0f0;
        }

        .tab-btn.active {
            background: #667eea;
            color: white;
        }

        .chart-section {
            display: none;
        }

        .chart-section.active {
            display: block;
        }
        
        .zoom-overlay {
            cursor: crosshair;
        }
        
        .zoom-overlay.active {
            fill: rgba(100, 150, 255, 0.05);
        }
        
        .zoom-selection {
            fill: rgba(100, 100, 200, 0.2);
            stroke: rgba(100, 100, 200, 0.8);
            stroke-width: 1;
            stroke-dasharray: 3,3;
        }
        
        .zoom-hint {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(102, 126, 234, 0.95);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            z-index: 2000;
            display: none;
            animation: fadeIn 0.3s ease-in;
        }
        
        .zoom-hint.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* ADD: Individual athlete section */
        .athlete-list {
            max-height: 12.5rem;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 0.3125rem;
            padding: 0.625rem;
        }
        
        /* ADD: Scrollable country section */
        .country-list {
            max-height: 8rem;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 0.3125rem;
            padding: 0.625rem;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.3125rem;
        }

        .athlete-item {
            display: flex;
            align-items: center;
            padding: 0.25rem;
            cursor: pointer;
            border-radius: 0.25rem;
            font-size: var(--font-size-xs);
            margin-bottom: 0.125rem;
            transition: all 0.3s ease;
            opacity: var(--athlete-opacity-visible);
        }

        .athlete-item:hover {
            background: #f0f0f0;
        }

        .athlete-item.hidden {
            opacity: var(--athlete-opacity-hidden);
            background: #f8f8f8;
        }
        
        .athlete-item:not(.hidden) {
            background: #e8f5e8;
        }

        .finishers-data {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(12.5rem, 1fr));
            gap: 1.25rem;
            padding: 1.25rem;
            background: white;
            border-radius: 0.625rem;
        }
            
        /* ADD: Mobile-specific chart styles */
        .mobile-chart-container {
            width: 100%;
            overflow: hidden;
            position: relative;
        }
        
        .mobile-chart-wrapper {
            transform-origin: 0 0;
            transition: transform 0.3s ease;
        }
        
        .mobile-zoom-controls {
            position: fixed;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 0.5rem;
            background: rgba(0,0,0,0.8);
            padding: 0.5rem;
            border-radius: 0.5rem;
            z-index: 1000;
        }
        
        .mobile-zoom-btn {
            background: #667eea;
            color: white;
            border: none;
            border-radius: 0.25rem;
            padding: 0.5rem;
            font-size: var(--font-size-sm);
            cursor: pointer;
        }
        
        .mobile-chart-hint {
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(102, 126, 234, 0.95);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            font-size: var(--font-size-xs);
            z-index: 1000;
            display: none;
        }
        
        .mobile-chart-hint.active {
            display: block;
        }

        /* ADD: Collapsible sidebar styles */
        .sidebar {
            position: fixed;
            left: -320px;
            top: 0;
            width: 320px;
            height: 100vh;
            background: white;
            border-right: 1px solid #e0e0e0;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            transition: left 0.3s ease;
            z-index: 1000;
            overflow-y: auto;
        }

        .sidebar.open {
            left: 0;
        }

        .sidebar-toggle {
            position: fixed;
            left: 10px;
            top: 100px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 12px;
            cursor: pointer;
            font-size: 16px;
            z-index: 1001;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            display: none;
        }

        .sidebar-toggle:hover {
            background: #5a67d8;
        }

        .sidebar.open + .sidebar-toggle {
            left: 340px;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
            background: #f8f9fa;
        }

        .sidebar-content {
            padding: 20px;
        }

        .sidebar-section {
            margin-bottom: 30px;
        }

        .sidebar-section-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 5px;
        }

        /* ADD: Adjust main content when sidebar is open */
        .main-content {
            transition: margin-left 0.3s ease;
        }

        .main-content.sidebar-open {
            margin-left: 320px;
        }

        @media (max-width: 768px) {
            .sidebar {
                width: 280px;
                left: -280px;
                z-index: 1002; /* Ensure sidebar is above content on mobile */
            }
            
            .sidebar.open + .sidebar-toggle {
                left: 290px;
            }
            
            .main-content.sidebar-open {
                margin-left: 0; /* Don't shift content on mobile */
            }
        }
        
        /* Desktop: Push content when sidebar opens */
        @media (min-width: 769px) {
            .main-content.sidebar-open {
                margin-left: 320px; /* Push content right on desktop */
            }
        }
        .dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .dialog-content {
            background: white;
            border-radius: 15px;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .dialog-header {
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .dialog-close {
            background: none;
            border: none;
            font-size: 30px;
            cursor: pointer;
            color: #666;
        }

        .dialog-body {
            padding: 20px;
        }

        .control-group {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }

        .control-group input[type="range"] {
            width: 70%;
            margin-right: 10px;
        }

        .pace-info {
            margin-top: 5px;
            font-size: 12px;
            color: #666;
        }

        .effort-warning {
            margin-top: 5px;
            padding: 5px;
            background: #fff3cd;
            border-radius: 4px;
            font-size: 12px;
            display: none;
        }

        .effort-warning.active {
            display: block;
        }

        .scenario-results {
            margin-top: 30px;
            padding: 20px;
            background: #e8f5e9;
            border-radius: 8px;
        }

        #scenarioComparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 15px;
        }

        .comparison-column {
            padding: 10px;
        }

        .comparison-column h5 {
            margin-bottom: 10px;
            color: #667eea;
        }

        .comparison-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            padding: 5px;
            background: white;
            border-radius: 4px;
        }
        #spiderChart {
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
            width: 100% !important;
            min-height: 500px;
        }

        #spiderChart svg {
            display: block !important;
            margin: 0 auto !important;
        }
    </style>
</head>
<body>
    <!-- ADD: Collapsible sidebar for controls -->
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <h3>Controls</h3>
        </div>
        <div class="sidebar-content" id="sidebarContent">
            <!-- Controls will be populated here -->
        </div>
    </div>
    
    <button class="sidebar-toggle" onclick="toggleSidebar()">‚ò∞</button>
    
    <div class="container main-content" id="mainContent">
        <h1>üèä‚Äç‚ôÇÔ∏èüö¥‚Äç‚ôÇÔ∏èüèÉ‚Äç‚ôÇÔ∏è Triathlon Results Visualizer</h1>
        
        <div class="upload-section" id="uploadSection">
            <div class="file-input-wrapper">
                <label for="csvFile" class="file-input-label" id="fileLabel">
                    Choose CSV File
                </label>
                <input type="file" id="csvFile" accept=".csv">
            </div>
            <div class="file-name" id="fileName"></div>
            <div class="error-message" id="errorMessage"></div>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Processing results...</p>
        </div>

        <div id="resultsSection" style="display: none;">
            <div class="tab-navigation">
                <button class="tab-btn active" onclick="showTab('summary')">üìä Summary</button>
                <button class="tab-btn" onclick="showTab('rank')">üìà Rank Chart</button>
                <button class="tab-btn" onclick="showTab('development')">üèÅ Race Chart</button>
                <button class="tab-btn" onclick="showTab('spider')">üï∏Ô∏è Spider Chart</button>
            </div>

            <!-- MODIFIED: Summary section now contains stats and finishers data -->
            <div id="summarySection" class="chart-section active">
                <div class="stats-summary" id="statsSummary"></div>
                <div class="finishers-data" id="finishersData" style="margin-top: 30px;"></div>
                <div class="top-performances" id="topPerformances" style="margin-top: 30px;"></div>
            </div>
            
            <div id="rankSection" class="chart-section">
                <div class="chart-container active">
                    <div class="chart-title">Race Position Changes</div>
                    <div id="rankChart"></div>
                </div>
            </div>

            <div id="developmentSection" class="chart-section">
                <div class="chart-container active">
                    <div class="chart-title">Race Progression</div>
                    <div id="developmentChart"></div>
                </div>
            </div>

            <div id="spiderSection" class="chart-section">
                <div class="chart-container active">
                    <div class="chart-title">Performance Comparison</div>
                    <div id="spiderChart"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>
    <div class="zoom-hint" id="zoomHint">Hold <strong>Shift</strong> and drag to select area to zoom</div>
    <!-- Hypothetical Analysis Dialog -->
    <div id="hypotheticalDialog" class="dialog-overlay" style="display: none;">
        <div class="dialog-content">
            <div class="dialog-header">
                <h3>Hypothetical Scenario Analysis</h3>
                <button class="dialog-close" onclick="closeHypotheticalDialog()">√ó</button>
            </div>
            <div class="dialog-body">
                <div id="athleteInfo"></div>
                
                <div class="scenario-controls">
                    <h4>Adjust Performance</h4>
                    
                    <div class="control-group">
                        <label>Swim Pace Adjustment</label>
                        <input type="range" id="swimAdjust" min="-20" max="20" value="0" step="1">
                        <span id="swimAdjustValue">0%</span>
                        <div class="pace-info" id="swimPaceInfo"></div>
                    </div>
                    
                    <div class="control-group">
                        <label>T1 Time</label>
                        <input type="range" id="t1Adjust" min="-30" max="30" value="0" step="1">
                        <span id="t1AdjustValue">0s</span>
                    </div>
                    
                    <div class="control-group">
                        <label>Bike Strategy</label>
                        <select id="bikeStrategy">
                            <option value="solo">Solo Effort</option>
                            <option value="leadPack">Lead Pack (Draft)</option>
                            <option value="chasePack">Chase Pack (Draft)</option>
                            <option value="custom">Custom Power</option>
                        </select>
                        <div id="bikeCustomControl" style="display: none;">
                            <input type="range" id="bikeAdjust" min="-20" max="20" value="0" step="1">
                            <span id="bikeAdjustValue">0%</span>
                        </div>
                        <div class="pace-info" id="bikePaceInfo"></div>
                    </div>
                    
                    <div class="control-group">
                        <label>T2 Time</label>
                        <input type="range" id="t2Adjust" min="-30" max="30" value="0" step="1">
                        <span id="t2AdjustValue">0s</span>
                    </div>
                    
                    <div class="control-group">
                        <label>Run Pace (affected by bike effort)</label>
                        <input type="range" id="runAdjust" min="-20" max="20" value="0" step="1">
                        <span id="runAdjustValue">0%</span>
                        <div class="pace-info" id="runPaceInfo"></div>
                        <div class="effort-warning" id="runEffortWarning"></div>
                    </div>
                </div>
                
                <div class="scenario-results">
                    <h4>Projected Outcome</h4>
                    <div id="scenarioComparison"></div>
                </div>
                
                <div class="scenario-visualization">
                    <div id="hypotheticalChart"></div>
                </div>
            </div>
        </div>
    </div>
    <div id="raceConfigDialog" class="dialog-overlay" style="display: none;">
        <div class="dialog-content" style="max-width: 500px;">
            <div class="dialog-header">
                <h3>Race Distance Configuration</h3>
                <button class="dialog-close" onclick="closeRaceConfigDialog()">√ó</button>
            </div>
            <div class="dialog-body">
                <div class="control-group">
                    <label>Race Type:</label>
                    <select id="raceTypeSelect" onchange="setRaceType()">
                        <option value="standard">Standard Distance</option>
                        <option value="sprint">Sprint Distance</option>
                        <option value="custom">Custom</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>Swim Distance (meters):</label>
                    <input type="number" id="swimDistance" value="1500" min="100" step="50">
                </div>
                
                <div class="control-group">
                    <label>Bike Distance (km):</label>
                    <input type="number" id="bikeDistance" value="40" min="1" step="1">
                </div>
                
                <div class="control-group">
                    <label>Run Distance (km):</label>
                    <input type="number" id="runDistance" value="10" min="1" step="0.5">
                </div>
                
                <button class="btn" onclick="saveRaceConfig()">Save Configuration</button>
            </div>
        </div>
    </div>
    <script>
        // Global variables
        let raceData = null;
        let processedData = null;
        let colorScale = null;
        let developmentSvg = null;
        let developmentG = null;
        let developmentChartData = null;
        let developmentAthleteVisibility = {};
        let developmentCountryVisibility = {};
        let spiderAthleteVisibility = {};
        let currentSection = 'all';
        let currentXScale = null;
        let currentYScale = null;
        let isMobile = window.innerWidth <= 768;
        let mobileScale = 1;
        let mobilePanX = 0;
        let mobilePanY = 0;
        let mobileIsPanning = false;
        let mobileTouchStart = { x: 0, y: 0 };
        let mobileLastTouchDistance = 0;
        let isVisible = false;
        let chartWidth = 0;
        let chartHeight = 0;
        let sectionBounds = {};
        let segmentLeaders = {};
        let originalXScale = null;
        let originalYScale = null;
        let stageDist = {};
        let zoomMode = false;
        let zoomRect = null;
        let zoomStartX = null;
        let zoomStartY = null;
        let lineGenerator = null;
        let hypotheticalAthlete = null;
        let hypotheticalStage = null;
        let bikePacks = {};   
        let teamColors = {};
        let teamColorIndex = 0;
        let manualRunOverride = false;

        const teamColorPalette = [
            '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', 
            '#dfe6e9', '#a29bfe', '#fd79a8', '#fdcb6e', '#6c5ce7'
        ];


        // Country flags mapping
        const countryFlags = {
            'AUS': 'üá¶üá∫', 'ITA': 'üáÆüáπ', 'HUN': 'üá≠üá∫', 'JPN': 'üáØüáµ', 'ESP': 'üá™üá∏',
            'CZE': 'üá®üáø', 'CHI': 'üá®üá±', 'CHL': 'üá®üá±', 'FRA': 'üá´üá∑', 'CAN': 'üá®üá¶', 
            'SUI': 'üá®üá≠', 'NED': 'üá≥üá±', 'GER': 'üá©üá™', 'BEL': 'üáßüá™', 'GBR': 'üá¨üáß', 
            'USA': 'üá∫üá∏', 'NZL': 'üá≥üáø', 'AUT': 'üá¶üáπ', 'POR': 'üáµüáπ', 'BRA': 'üáßüá∑', 
            'MEX': 'üá≤üáΩ', 'ARG': 'üá¶üá∑', 'RSA': 'üáøüá¶', 'NOR': 'üá≥üá¥', 'SWE': 'üá∏üá™', 
            'DEN': 'üá©üá∞'
        };
        // Race distance configuration
        let raceConfig = {
            swim: 1500,  // meters
            bike: 40,    // kilometers
            run: 10      // kilometers
        };

        // FIX: Better chart configuration with appropriate aspect ratios
        const chartConfig = {
            getMargins: (chartType = 'default') => {
                const containerWidth = window.innerWidth - 80;
                if (chartType === 'spider') {
                    // Spider chart needs equal margins
                    const margin = isMobile ? 40 : 60;
                    return {
                        top: margin,
                        right: margin,
                        bottom: margin,
                        left: margin
                    };
                }
                // Rank and development charts need more horizontal space
                return isMobile ? {
                    top: 30,
                    right: 100,
                    bottom: 50,
                    left: 50
                } : {
                    top: 40,
                    right: 150,
                    bottom: 80,
                    left: 100
                };
            },
            getDimensions: (containerId, chartType = 'default') => {
                const container = document.getElementById(containerId);
                const containerWidth = (container?.parentElement?.offsetWidth || window.innerWidth - 40);
                
                if (chartType === 'spider') {
                    // Spider chart should be smaller and square
                    const margin = chartConfig.getMargins('spider');
                    const maxSize = isMobile ? containerWidth - 80 : Math.min(500, containerWidth * 0.5);
                    const size = maxSize - margin.left - margin.right;
                    return { 
                        width: size, 
                        height: size, 
                        margin 
                    };
                } else {
                    // Rank and development charts should use most of available width
                    const margin = chartConfig.getMargins('default');
                    const availableWidth = containerWidth - 40;
                    const width = availableWidth - margin.left - margin.right;
                    
                    // Height based on data density
                    let height;
                    if (chartType === 'rank' && processedData) {
                        // Rank chart height based on number of athletes
                        const rowHeight = isMobile ? 12 : 15;
                        height = Math.max(400, processedData.length * rowHeight);
                    } else {
                        // Development chart with good aspect ratio
                        height = isMobile ? Math.min(500, width * 0.6) : Math.min(600, width * 0.5);
                    }
                    
                    return { width, height, margin };
                }
            },
            setupAxes: (g, xScale, yScale, height, chartWidth, xLabel, yLabel) => {
                // X-axis grid
                g.append("g")
                    .attr("class", "grid grid-x")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(xScale).tickSize(-height).tickFormat(""));
                
                // Y-axis grid
                g.append("g")
                    .attr("class", "grid grid-y")
                    .call(d3.axisLeft(yScale).tickSize(-chartWidth).tickFormat(""));
                
                // X-axis
                g.append("g")
                    .attr("class", "x-axis axis")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(xScale));
                
                // Y-axis
                g.append("g")
                    .attr("class", "y-axis axis")
                    .call(d3.axisLeft(yScale));
                
                // X-axis label
                if (xLabel) {
                    g.append("text")
                        .attr("class", "x-axis-label axis-label")
                        .attr("transform", `translate(${chartWidth/2}, ${height + 45})`)
                        .style("text-anchor", "middle")
                        .text(xLabel);
                }
                
                // Y-axis label
                if (yLabel) {
                    g.append("text")
                        .attr("class", "y-axis-label axis-label")
                        .attr("transform", "rotate(-90)")
                        .attr("y", -70)
                        .attr("x", -(height / 2))
                        .attr("dy", "1em")
                        .style("text-anchor", "middle")
                        .text(yLabel);
                }
            }
        };
        
        // ADD: Common control population function
        function populateControls(container, chartType) {
            if (!processedData) return;
            
            const config = chartType === 'spider' ? {
                visibilityObj: spiderAthleteVisibility,
                toggleAllFn: toggleAllSpiderAthletes,
                toggleGroupFn: toggleSpiderAthleteGroup,
                toggleIndividualFn: toggleIndividualSpiderAthlete,
                toggleCountryFn: toggleSpiderCountry,
                toggleBtnId: 'spiderToggleBtn',
                defaultVisibility: (athlete) => athlete.finalRank && athlete.finalRank <= 5 && !['DNF', 'LAP', 'DSQ'].includes(athlete.status),
                includeSectionButtons: false
            } : {
                visibilityObj: developmentAthleteVisibility,
                toggleAllFn: toggleAllAthletes,
                toggleGroupFn: toggleAthleteGroup,
                toggleIndividualFn: toggleIndividualAthlete,
                toggleCountryFn: toggleCountry,
                toggleBtnId: 'athleteToggleBtn',
                defaultVisibility: () => true,
                includeSectionButtons: true
            };
            
            container.innerHTML = '';
            
            // Section controls (only for development chart)
            if (config.includeSectionButtons) {
                const sectionDiv = document.createElement('div');
                sectionDiv.className = 'sidebar-section';
                sectionDiv.innerHTML = '<div class="sidebar-section-title">Race Sections</div>';
                
                const sectionButtons = [
                    { key: 'all', label: 'All' },
                    { key: 'swim', label: 'Swim' },
                    { key: 't1', label: 'T1' },
                    { key: 'bike', label: 'Bike' },
                    { key: 't2', label: 'T2' },
                    { key: 'run', label: 'Run' }
                ];
                
                const controlsDiv = document.createElement('div');
                controlsDiv.className = 'controls';
                controlsDiv.style.display = 'grid';
                controlsDiv.style.gridTemplateColumns = 'repeat(2, 1fr)';
                controlsDiv.style.gap = '5px';
                
                sectionButtons.forEach(btn => {
                    const button = document.createElement('button');
                    button.className = `btn ${currentSection === btn.key ? 'active' : ''}`;
                    button.textContent = btn.label;
                    button.style.padding = '8px 12px';
                    button.style.fontSize = '13px';
                    button.onclick = () => showSection(btn.key);
                    controlsDiv.appendChild(button);
                });
                
                if (!isMobile) {
                    const zoomButton = document.createElement('button');
                    zoomButton.className = 'btn';
                    zoomButton.textContent = 'üîç Zoom (Hold Shift)';
                    zoomButton.title = 'Hold Shift key and drag to zoom';
                    zoomButton.onclick = enableZoomMode;
                    controlsDiv.appendChild(zoomButton);
                }
                
                sectionDiv.appendChild(controlsDiv);
                container.appendChild(sectionDiv);
            }
            
            // Athlete selection
            const athleteDiv = document.createElement('div');
            athleteDiv.className = 'sidebar-section';
            athleteDiv.innerHTML = '<div class="sidebar-section-title">Athletes</div>';
            
            // Toggle all button
            const toggleDiv = document.createElement('div');
            toggleDiv.style.marginBottom = '15px';
            
            const toggleBtn = document.createElement('button');
            toggleBtn.className = 'btn toggle-all';
            toggleBtn.textContent = chartType === 'spider' ? 'Hide All' : 'Hide All';  // Start with Hide All for both
            toggleBtn.id = config.toggleBtnId;
            //For spider remove show all functionality
            toggleBtn.onclick = function() {
                const showAll = this.textContent === 'Show All';
                this.textContent = showAll ? 'Hide All' : 'Show All';
                config.toggleAllFn(showAll);
            };

            
            toggleDiv.appendChild(toggleBtn);
            athleteDiv.appendChild(toggleDiv);
            
            // Group selection
            const groupHeaderDiv = document.createElement('div');
            groupHeaderDiv.innerHTML = '<strong>Groups:</strong>';
            groupHeaderDiv.style.marginBottom = '5px';
            athleteDiv.appendChild(groupHeaderDiv);
            
            const groupScrollDiv = document.createElement('div');
            groupScrollDiv.className = 'athlete-list';
            groupScrollDiv.style.maxHeight = '120px';
            groupScrollDiv.style.marginBottom = '15px';
            
            const groups = chartType === 'spider' ? [
                { name: "Top 5", range: [1, 5] },
                { name: "6-10", range: [6, 10] },
                { name: "11-20", range: [11, 20] },
                { name: "21+", range: [21, Infinity] }
            ] : [
                { name: "Top 10", range: [1, 10] },
                { name: "11-20", range: [11, 20] },
                { name: "21-30", range: [21, 30] },
                { name: "31+", range: [31, Infinity] },
                { name: "DNF/DSQ", special: true }
            ];
            
            groups.forEach(group => {
                const groupBtn = document.createElement('button');
                groupBtn.className = 'btn';
                groupBtn.textContent = group.name;
                groupBtn.style.fontSize = '12px';
                groupBtn.style.padding = '8px 12px';
                groupBtn.style.margin = '2px';
                groupBtn.style.width = 'calc(100% - 4px)';
                groupBtn.onclick = () => config.toggleGroupFn(group);
                groupScrollDiv.appendChild(groupBtn);
            });
            
            athleteDiv.appendChild(groupScrollDiv);
            
            // Individual athletes
            const individualDiv = document.createElement('div');
            individualDiv.innerHTML = '<strong>Individual Athletes:</strong>';
            individualDiv.style.marginTop = '15px';
            individualDiv.style.marginBottom = '10px';
            
            const athleteListDiv = document.createElement('div');
            athleteListDiv.className = 'athlete-list';
            
            const sortedAthletes = [...processedData].sort((a, b) => {
                if (a.finalRank && b.finalRank) return a.finalRank - b.finalRank;
                if (a.finalRank) return -1;
                if (b.finalRank) return 1;
                return a.name.localeCompare(b.name);
            });
            
            sortedAthletes.forEach((athlete) => {
                const athleteIndex = processedData.indexOf(athlete);
                const isVisible = config.visibilityObj[athlete.name] !== false;
                
                const athleteBtn = document.createElement('button');
                athleteBtn.className = `btn ${isVisible ? '' : 'hidden'}`;
                athleteBtn.style.width = '100%';
                athleteBtn.style.textAlign = 'left';
                athleteBtn.style.padding = '8px 12px';
                athleteBtn.style.fontSize = '12px';
                athleteBtn.style.marginBottom = '2px';
                athleteBtn.style.height = '36px';
                
                const color = colorScale(athlete.name);
                athleteBtn.style.backgroundColor = `${color}99`;
                athleteBtn.style.border = `2px solid ${color}`;
                athleteBtn.style.color = '#000';
                
                const rank = athlete.finalRank ? `${athlete.finalRank}.` : '';
                const flag = countryFlags[athlete.country] || 'üè¥';
                const name = athlete.baseName || athlete.name.replace(/ \([^)]*\)$/, '');
                athleteBtn.innerHTML = `${rank} ${name} ${flag}`;
                
                if (chartType === 'spider') {
                    athleteBtn.onclick = () => config.toggleIndividualFn(athlete.name);
                } else {
                    athleteBtn.onclick = () => config.toggleIndividualFn(athlete.name, athleteIndex);
                }
                
                athleteListDiv.appendChild(athleteBtn);
            });
            
            individualDiv.appendChild(athleteListDiv);
            athleteDiv.appendChild(individualDiv);
            
            // Country selection
            const countryDiv = document.createElement('div');
            countryDiv.innerHTML = '<strong>Countries:</strong>';
            countryDiv.style.marginTop = '15px';
            countryDiv.style.marginBottom = '10px';
            
            const countryListDiv = document.createElement('div');
            countryListDiv.className = 'country-list';
            
            const countries = [...new Set(processedData.map(d => d.country))].sort();
            countries.forEach(country => {
                if (chartType === 'development' && developmentCountryVisibility[country] === undefined) {
                    developmentCountryVisibility[country] = true;
                }
                
                const isVisible = chartType === 'spider' ? 
                    processedData.some(a => a.country === country && config.visibilityObj[a.name]) :
                    developmentCountryVisibility[country];
                
                const countryBtn = document.createElement('button');
                countryBtn.className = `btn ${isVisible ? '' : 'hidden'}`;
                countryBtn.style.fontSize = '11px';
                countryBtn.style.padding = '6px 4px';
                countryBtn.style.margin = '0';
                countryBtn.style.height = '36px';
                countryBtn.style.display = 'flex';
                countryBtn.style.alignItems = 'center';
                countryBtn.style.justifyContent = 'center';
                countryBtn.innerHTML = `<span class="country-flag">${countryFlags[country] || 'üè¥'}</span><span>${country}</span>`;
                countryBtn.title = country;
                countryBtn.onclick = () => config.toggleCountryFn(country);
                countryListDiv.appendChild(countryBtn);
            });
            
            countryDiv.appendChild(countryListDiv);
            athleteDiv.appendChild(countryDiv);
            container.appendChild(athleteDiv);
        }
        
        // Show/hide desktop elements based on screen size
        function updateDesktopElements() {
            const desktopElements = document.querySelectorAll('.desktop-only');
            desktopElements.forEach(el => {
                el.style.display = isMobile ? 'none' : '';
            });
            
            if (isMobile) {
                setupMobileCharts();
            }
        }
        
        // ADD: Mobile chart setup
        function setupMobileCharts() {
            const rankChart = document.getElementById('rankChart');
            const developmentChart = document.getElementById('developmentChart');
            
            if (rankChart && !rankChart.classList.contains('mobile-setup')) {
                setupMobileChart(rankChart);
            }
            if (developmentChart && !developmentChart.classList.contains('mobile-setup')) {
                setupMobileChart(developmentChart);
            }
        }
        
        function setupMobileChart(chartElement) {
            chartElement.classList.add('mobile-setup');
            
            const wrapper = document.createElement('div');
            wrapper.className = 'mobile-chart-wrapper';
            chartElement.parentNode.insertBefore(wrapper, chartElement);
            wrapper.appendChild(chartElement);
            
            const container = document.createElement('div');
            container.className = 'mobile-chart-container';
            wrapper.parentNode.insertBefore(container, wrapper);
            container.appendChild(wrapper);
            
            mobileScale = 0.6;
            wrapper.style.transform = `scale(${mobileScale})`;
            
            setupMobileTouchEvents(container, wrapper);
        }
        
        function setupMobileTouchEvents(container, wrapper) {
            let lastTap = 0;
            let longPressTimer = null;
            
            container.addEventListener('touchend', function(e) {
                e.preventDefault();
                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastTap;
                
                if (tapLength < 500 && tapLength > 0) {
                    resetMobileZoom();
                } else {
                    const touch = e.changedTouches[0];
                    highlightNearestAthlete(touch.clientX, touch.clientY);
                }
                lastTap = currentTime;
                
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            });
            
            container.addEventListener('touchstart', function(e) {
                const touch = e.touches[0];
                longPressTimer = setTimeout(() => {
                    showMobileTooltip(touch.clientX, touch.clientY);
                    longPressTimer = null;
                }, 500);
                
                mobileTouchStart = { x: touch.clientX, y: touch.clientY };
            });
            
            container.addEventListener('touchmove', function(e) {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                
                if (e.touches.length === 2) {
                    e.preventDefault();
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const distance = Math.sqrt(
                        Math.pow(touch2.clientX - touch1.clientX, 2) + 
                        Math.pow(touch2.clientY - touch1.clientY, 2)
                    );
                    
                    if (mobileLastTouchDistance > 0) {
                        const scale = distance / mobileLastTouchDistance;
                        mobileZoom(scale);
                    }
                    mobileLastTouchDistance = distance;
                } else if (e.touches.length === 1 && mobileScale > 0.6) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - mobileTouchStart.x;
                    const deltaY = touch.clientY - mobileTouchStart.y;
                    
                    mobilePanX += deltaX / mobileScale;
                    mobilePanY += deltaY / mobileScale;
                    
                    wrapper.style.transform = `scale(${mobileScale}) translate(${mobilePanX}px, ${mobilePanY}px)`;
                    
                    mobileTouchStart = { x: touch.clientX, y: touch.clientY };
                }
            });
            
            container.addEventListener('touchcancel', function() {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                mobileLastTouchDistance = 0;
            });
        }
        
        function mobileZoom(factor) {
            mobileScale = Math.max(0.3, Math.min(3, mobileScale * factor));
            const wrapper = document.querySelector('.mobile-chart-wrapper');
            if (wrapper) {
                wrapper.style.transform = `scale(${mobileScale}) translate(${mobilePanX}px, ${mobilePanY}px)`;
            }
        }
        
        function resetMobileZoom() {
            mobileScale = 0.6;
            mobilePanX = 0;
            mobilePanY = 0;
            const wrapper = document.querySelector('.mobile-chart-wrapper');
            if (wrapper) {
                wrapper.style.transform = `scale(${mobileScale})`;
            }
        }
        
        function highlightNearestAthlete(x, y) {
            d3.selectAll('.athlete-path, .athlete-line').attr('opacity', 0.4).attr('stroke-width', 1.5);
            
            const hint = document.querySelector('.mobile-chart-hint') || createMobileHint();
            hint.classList.add('active');
            hint.textContent = 'Tap highlighted athlete, long press for details';
            setTimeout(() => hint.classList.remove('active'), 3000);
            
            const randomIndex = Math.floor(Math.random() * (processedData ? processedData.length : 5));
            d3.selectAll(`.athlete-path-${randomIndex}, .athlete-group-${randomIndex} .athlete-line`)
                .attr('opacity', 1)
                .attr('stroke-width', 3);
        }
        
        function showMobileTooltip(x, y) {
            const tooltip = d3.select('#tooltip');
            if (processedData && processedData.length > 0) {
                const randomAthlete = processedData[Math.floor(Math.random() * processedData.length)];
                const name = randomAthlete.baseName || randomAthlete.name.replace(/ \([^)]*\)$/, '');
                tooltip.html(`<strong>${name} (${randomAthlete.finalRank || 'N/A'})</strong><br/>${randomAthlete.country}`)
                    .style('left', (x + 10) + 'px')
                    .style('top', (y - 28) + 'px')
                    .style('opacity', 0.9);
                
                setTimeout(() => tooltip.style('opacity', 0), 4000);
            }
        }
        
        function createMobileHint() {
            const hint = document.createElement('div');
            hint.className = 'mobile-chart-hint';
            document.body.appendChild(hint);
            return hint;
        }
        
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        // FIX: Redraw all charts on resize, not just the active one
        window.addEventListener('resize', debounce(() => {
            isMobile = window.innerWidth <= 768;
            updateDesktopElements();
            
            if (processedData && processedData.length > 0) {
                // Redraw all charts
                drawRankChart(processedData);
                drawDevelopmentChart(processedData);
                updateSpiderChart();
                
                if (isMobile) {
                    setTimeout(setupMobileCharts, 100);
                }
            }
        }, 250));
        
        document.addEventListener('DOMContentLoaded', function() {
            const tabNav = document.querySelector('.tab-navigation');
            if (tabNav) {
                const settingsBtn = document.createElement('button');
                settingsBtn.className = 'tab-btn';
                settingsBtn.innerHTML = '‚öôÔ∏è Settings';
                settingsBtn.onclick = openRaceConfigDialog;
                tabNav.appendChild(settingsBtn);
            }
        });        
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const mainContent = document.getElementById('mainContent');
            
            sidebar.classList.toggle('open');
            if (!isMobile) {
                mainContent.classList.toggle('sidebar-open');
            }
        }
        
        // Tab navigation
        function showTab(tabName) {
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Find and activate the clicked button
            document.querySelectorAll('.tab-btn').forEach(btn => {
                if (btn.textContent.toLowerCase().includes(tabName.toLowerCase()) || 
                    (tabName === 'summary' && btn.textContent.includes('Summary')) ||
                    (tabName === 'rank' && btn.textContent.includes('Rank')) ||
                    (tabName === 'development' && btn.textContent.includes('Race Chart')) ||
                    (tabName === 'spider' && btn.textContent.includes('Spider'))) {
                    btn.classList.add('active');
                }
            });
            
            document.querySelectorAll('.chart-section').forEach(section => {
                section.classList.remove('active');
            });
            document.getElementById(tabName + 'Section').classList.add('active');
            
            // Handle sidebar visibility
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.querySelector('.sidebar-toggle');
            const wasOpen = sidebar.classList.contains('open');
            
            // Close sidebar for tabs that don't need it
            if (tabName === 'rank' || tabName === 'summary') {
                if (wasOpen) {
                    sidebar.classList.remove('open');
                    document.getElementById('mainContent').classList.remove('sidebar-open');
                }
                sidebarToggle.style.display = 'none';
                
                // Delay chart drawing to allow DOM to update
                setTimeout(() => {
                    if (processedData && processedData.length > 0) {
                        if (tabName === 'rank') {
                            drawRankChart(processedData);
                        }
                    }
                }, 350); // Wait for sidebar transition (0.3s) + buffer
            } else {
                // Show sidebar button for development and spider
                sidebarToggle.style.display = 'block';
                
                // Draw charts immediately for tabs with sidebar
                if (processedData && processedData.length > 0) {
                    if (tabName === 'development') {
                        drawDevelopmentChart(processedData);
                    } else if (tabName === 'spider') {
                        updateSpiderChart();
                    }
                }
                
                // Populate sidebar after chart is drawn
                setTimeout(() => populateSidebar(tabName), 100);
            }
        }        
        function populateSidebar(tabName) {
            const sidebarContent = document.getElementById('sidebarContent');
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.querySelector('.sidebar-toggle');
            
            // Always show the button for development and spider charts
            if (tabName === 'development' || tabName === 'spider') {
                sidebarToggle.style.display = 'block';
                populateControls(sidebarContent, tabName);
            } else {
                if (sidebar.classList.contains('open')) {
                    toggleSidebar();
                }
                sidebarToggle.style.display = 'none';
                sidebarContent.innerHTML = ''; // Clear content
            }
        }
        function toggleAllAthletes(show) {
            if (!processedData) return;
            
            // Reset country visibility states
            const countries = [...new Set(processedData.map(d => d.country))];
            countries.forEach(country => {
                developmentCountryVisibility[country] = show;  // Reset to boolean, not 'selected'
            });
            
            // Reset team colors when hiding all
            if (!show) {
                teamColors = {};
                teamColorIndex = 0;
            }
            
            processedData.forEach((athlete, index) => {
                developmentAthleteVisibility[athlete.name] = show;
                d3.selectAll(`.athlete-path-${index}`).classed("hidden", !show);
                d3.selectAll(`.athlete-path-hitarea-${index}`).classed("hidden", !show);
                d3.selectAll(`.athlete-circle-${index}`).classed("hidden", !show);
            });
            
            updateDevelopmentChart();
            drawTeamHighlights(); // This will clear highlights since no countries are 'selected'
            
            // Update all button states
            document.querySelectorAll('#sidebarContent .btn:not(.toggle-all)').forEach(btn => {
                if (show) {
                    btn.classList.remove('hidden');
                    btn.style.opacity = '';
                    btn.style.backgroundColor = '';
                } else {
                    btn.classList.add('hidden');
                    btn.style.opacity = '0.3';
                    btn.style.backgroundColor = '';
                }
            });
        }
        
        function toggleAthleteGroup(group) {
            if (!processedData) return;
            
            processedData.forEach((athlete, index) => {
                let inGroup = false;
                if (group.special) {
                    inGroup = ['DNF', 'DSQ', 'LAP'].includes(athlete.status);
                } else {
                    const pos = athlete.finalRank || 999;
                    inGroup = pos >= group.range[0] && pos <= group.range[1];
                }
                
                if (inGroup) {
                    developmentAthleteVisibility[athlete.name] = !developmentAthleteVisibility[athlete.name];
                    const isVisible = developmentAthleteVisibility[athlete.name];
                    d3.selectAll(`.athlete-path-${index}`).classed("hidden", !isVisible);
                    d3.selectAll(`.athlete-path-hitarea-${index}`).classed("hidden", !isVisible); // ADD THIS
                    d3.selectAll(`.athlete-circle-${index}`).classed("hidden", !isVisible);
                }
            });
            
            updateDevelopmentChart();
            
            processedData.forEach((athlete) => {
                const athleteButtons = document.querySelectorAll('#sidebarContent .btn');
                athleteButtons.forEach(btn => {
                    if (btn.textContent.includes(athlete.baseName || athlete.name.split(' ')[1] || athlete.name)) {
                        if (developmentAthleteVisibility[athlete.name]) {
                            btn.classList.remove('hidden');
                        } else {
                            btn.classList.add('hidden');
                        }
                    }
                });
            });
        }
        function toggleCountry(country) {
            // Toggle between three states: true (visible), 'selected' (highlighted), false (hidden)
            if (developmentCountryVisibility[country] === 'selected') {
                // Currently selected, hide all
                developmentCountryVisibility[country] = false;
                processedData.forEach((athlete, index) => {
                    if (athlete.country === country) {
                        developmentAthleteVisibility[athlete.name] = false;
                        d3.selectAll(`.athlete-path-${index}`).classed("hidden", true);
                        d3.selectAll(`.athlete-path-hitarea-${index}`).classed("hidden", true);
                        d3.selectAll(`.athlete-circle-${index}`).classed("hidden", true);
                    }
                });
            } else {
                // Not selected, select and highlight
                developmentCountryVisibility[country] = 'selected';
                processedData.forEach((athlete, index) => {
                    if (athlete.country === country) {
                        developmentAthleteVisibility[athlete.name] = true;
                        d3.selectAll(`.athlete-path-${index}`).classed("hidden", false);
                        d3.selectAll(`.athlete-path-hitarea-${index}`).classed("hidden", false);
                        d3.selectAll(`.athlete-circle-${index}`).classed("hidden", false);
                    }
                });
            }
            
            updateDevelopmentChart();
            drawTeamHighlights();
            
            // Update ALL button visual states
            const buttons = document.querySelectorAll('#sidebarContent .btn');
            buttons.forEach(btn => {
                // Country button
                if (btn.title === country || (btn.textContent.includes(country) && btn.textContent.includes('üá¶'))) {
                    if (developmentCountryVisibility[country] === 'selected') {
                        btn.classList.remove('hidden');
                        btn.style.opacity = '1';
                        btn.style.backgroundColor = getTeamColor(country) + '40';
                        btn.style.border = `2px solid ${getTeamColor(country)}`;
                    } else {
                        btn.classList.add('hidden');
                        btn.style.opacity = '0.3';
                        btn.style.backgroundColor = '';
                        btn.style.border = '';
                    }
                }
            });
            
            // Update individual athlete buttons based on their country
            processedData.forEach((athlete, index) => {
                const athleteButtons = document.querySelectorAll('#sidebarContent .btn');
                athleteButtons.forEach(btn => {
                    const btnText = btn.textContent;
                    const athleteNameInButton = athlete.baseName || athlete.name.split(' ')[1] || athlete.name;
                    
                    if (btnText.includes(athleteNameInButton) && !btnText.includes('üá¶')) { // Check it's an athlete button, not country
                        if (athlete.country === country) {
                            if (developmentCountryVisibility[country] === 'selected') {
                                btn.classList.remove('hidden');
                                btn.style.opacity = '1'; // Full opacity for selected team members
                                // Add subtle team color border
                                btn.style.border = `2px solid ${getTeamColor(country)}`;
                            } else if (developmentCountryVisibility[country]) {
                                btn.classList.remove('hidden');
                                btn.style.opacity = '0.7';
                                btn.style.border = '';
                            } else {
                                btn.classList.add('hidden');
                                btn.style.opacity = '0.3';
                                btn.style.border = '';
                            }
                        }
                    }
                });
            });
        }        
        function getTeamColor(country) {
            if (!teamColors[country]) {
                teamColors[country] = teamColorPalette[teamColorIndex % teamColorPalette.length];
                teamColorIndex++;
            }
            return teamColors[country];
        }
        function drawTeamHighlights() {
            if (!developmentG || !developmentChartData) return;
            
            // Remove existing team highlights
            developmentG.selectAll(".team-highlight-path").remove();
            
            // Check which countries have been explicitly selected via country buttons
            const selectedCountries = [];
            Object.keys(developmentCountryVisibility).forEach(country => {
                // Only highlight if country button was explicitly toggled on
                if (developmentCountryVisibility[country] === 'selected') {
                    selectedCountries.push(country);
                }
            });
            
            if (selectedCountries.length === 0) return;
            
            // Create highlight layer if it doesn't exist
            let highlightLayer = developmentG.select(".team-highlight-layer");
            if (highlightLayer.empty()) {
                highlightLayer = developmentG.select(".chart-content")
                    .insert("g", ":first-child")
                    .attr("class", "team-highlight-layer")
                    .attr("clip-path", "url(#chart-clip)");
            }
            
            // For each selected country, highlight all athletes from that country
            selectedCountries.forEach(country => {
                const teamColor = getTeamColor(country);
                
                developmentChartData.forEach((athlete, index) => {
                    if (athlete.country === country && developmentAthleteVisibility[athlete.name]) {
                        // Add a thicker colored background line for each athlete
                        highlightLayer.append("path")
                            .datum(athlete.values)
                            .attr("class", `team-highlight-path team-highlight-${country}`)
                            .attr("d", lineGenerator)
                            .attr("fill", "none")
                            .attr("stroke", teamColor)
                            .attr("stroke-width", 6)
                            .attr("opacity", 0.4)
                            .attr("pointer-events", "none");
                    }
                });
            });
        }
        function toggleAllSpiderAthletes(show) {
            if (!processedData) return;

            processedData.forEach((athlete) => {
                spiderAthleteVisibility[athlete.name] = show;
            });
            updateSpiderChart();
            
            // Update button states in sidebar
            document.querySelectorAll('#sidebarContent .btn:not(.toggle-all)').forEach(btn => {
                if (show) {
                    btn.classList.remove('hidden');
                } else {
                    btn.classList.add('hidden');
                }
            });
        }
        
        function toggleSpiderAthleteGroup(group) {
            if (!processedData) return;
            
            processedData.forEach((athlete) => {
                const pos = athlete.finalRank || 999;
                if (pos >= group.range[0] && pos <= group.range[1]) {
                    spiderAthleteVisibility[athlete.name] = true;
                }
            });
            
            updateSpiderChart();
            
            // Update button states in sidebar
            processedData.forEach((athlete) => {
                const athleteButtons = document.querySelectorAll('#sidebarContent .btn');
                athleteButtons.forEach(btn => {
                    if (btn.textContent.includes(athlete.baseName || athlete.name.split(' ')[1] || athlete.name)) {
                        if (spiderAthleteVisibility[athlete.name]) {
                            btn.classList.remove('hidden');
                        } else {
                            btn.classList.add('hidden');
                        }
                    }
                });
            });
        }
        
        function toggleSpiderCountry(country) {
            if (!processedData) return;
            
            const athletes = processedData.filter(a => a.country === country);
            const anyVisible = athletes.some(a => spiderAthleteVisibility[a.name]);
            const newVisibility = !anyVisible;
            
            athletes.forEach(athlete => {
                spiderAthleteVisibility[athlete.name] = newVisibility;
            });
            updateSpiderChart();
            
            // Update button states in sidebar
            const buttons = document.querySelectorAll('#sidebarContent .btn');
            buttons.forEach(btn => {
                if (btn.title === country || btn.textContent.includes(country)) {
                    if (newVisibility) {
                        btn.classList.remove('hidden');
                    } else {
                        btn.classList.add('hidden');
                    }
                }
                athletes.forEach(athlete => {
                    if (btn.textContent.includes(athlete.baseName || athlete.name.split(' ')[1])) {
                        if (newVisibility) {
                            btn.classList.remove('hidden');
                        } else {
                            btn.classList.add('hidden');
                        }
                    }
                });
            });
        }

        function showSection(section) {
            currentSection = section;
            zoomMode = false;
            
            document.getElementById('zoomHint').classList.remove('active');
            
            // ADD: Just update the current section button to active without removing others
            const sectionButtons = document.querySelectorAll('#sidebarContent .controls .btn');
            sectionButtons.forEach(btn => {
                if (btn.textContent.toLowerCase() === section || 
                    (section === 'all' && btn.textContent === 'All')) {
                    btn.classList.add('active');
                }
            });
                    
            if (developmentSvg) {
                developmentSvg.select(".zoom-overlay").remove();
                developmentSvg.select(".zoom-selection").remove();
            }
            
            d3.select(window).on("mousemove.zoom", null);
            d3.select(window).on("mouseup.zoom", null);
            d3.select(window).on("keydown.zoom", null);
            d3.select(window).on("keyup.zoom", null);
            
            updateDevelopmentChart();
        }
        
        function enableZoomMode() {
            zoomMode = true;
            currentSection = 'zoom';
            document.querySelectorAll('.controls .btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            document.getElementById('zoomHint').classList.add('active');
            
            if (developmentSvg) {
                const margin = chartConfig.getMargins();
                
                developmentSvg.select(".zoom-overlay").remove();
                
                let isDragging = false;
                let overlayActive = false;
                
                const zoomOverlay = developmentSvg.append("rect")
                    .attr("class", "zoom-overlay")
                    .attr("x", margin.left)
                    .attr("y", margin.top)
                    .attr("width", chartWidth)
                    .attr("height", chartHeight)
                    .style("fill", "none")
                    .style("pointer-events", "none")
                    .style("cursor", "crosshair");
                
                const svgNode = developmentSvg.node();
                const zoomHint = document.getElementById('zoomHint');
                
                d3.select(window).on("keydown.zoom", function(event) {
                    if (event.key === 'Shift' && zoomMode && !isDragging) {
                        zoomOverlay.style("pointer-events", "all").classed("active", true);
                        overlayActive = true;
                        zoomHint.innerHTML = 'Drag to select area to zoom';
                        zoomHint.style.background = 'rgba(40, 167, 69, 0.95)';
                    }
                });
                
                d3.select(window).on("keyup.zoom", function(event) {
                    if (event.key === 'Shift' && !isDragging) {
                        zoomOverlay.style("pointer-events", "none").classed("active", false);
                        overlayActive = false;
                        zoomHint.innerHTML = 'Hold <strong>Shift</strong> and drag to select area to zoom';
                        zoomHint.style.background = 'rgba(102, 126, 234, 0.95)';
                    }
                });
                
                zoomOverlay.on("mousedown", function(event) {
                    if (!zoomMode || !overlayActive) return;
                    
                    isDragging = true;
                    const [x, y] = d3.pointer(event, this);
                    zoomStartX = x - margin.left;
                    zoomStartY = y - margin.top;
                    
                    d3.select(this).style("pointer-events", "all");
                    
                    developmentSvg.select(".zoom-selection").remove();
                    
                    zoomRect = developmentSvg.append("rect")
                        .attr("class", "zoom-selection")
                        .attr("x", x)
                        .attr("y", y)
                        .attr("width", 0)
                        .attr("height", 0);
                    
                    event.preventDefault();
                });
                
                d3.select(window).on("mousemove.zoom", function(event) {
                    if (!zoomMode || !isDragging || !zoomRect) return;
                    
                    const rect = svgNode.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const y = event.clientY - rect.top;
                    
                    const currentX = Math.min(Math.max(0, x - margin.left), chartWidth);
                    const currentY = Math.min(Math.max(0, y - margin.top), chartHeight);
                    
                    const width = Math.abs(currentX - zoomStartX);
                    const height = Math.abs(currentY - zoomStartY);
                    
                    zoomRect
                        .attr("x", Math.min(currentX, zoomStartX) + margin.left)
                        .attr("y", Math.min(currentY, zoomStartY) + margin.top)
                        .attr("width", width)
                        .attr("height", height);
                });
                
                d3.select(window).on("mouseup.zoom", function(event) {
                    if (!zoomMode || !isDragging || !zoomRect) return;
                    
                    isDragging = false;
                    
                    const rect = svgNode.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const y = event.clientY - rect.top;
                    
                    const endX = Math.min(Math.max(0, x - margin.left), chartWidth);
                    const endY = Math.min(Math.max(0, y - margin.top), chartHeight);
                    
                    if (Math.abs(endX - zoomStartX) > 10 && Math.abs(endY - zoomStartY) > 10) {
                        const x1 = Math.min(zoomStartX, endX);
                        const x2 = Math.max(zoomStartX, endX);
                        const y1 = Math.min(zoomStartY, endY);
                        const y2 = Math.max(zoomStartY, endY);
                        
                        const xDomain = [
                            currentXScale.invert(x1),
                            currentXScale.invert(x2)
                        ];
                        const yDomain = [
                            currentYScale.invert(y2),
                            currentYScale.invert(y1)
                        ];
                        
                        currentXScale.domain(xDomain);
                        currentYScale.domain(yDomain);
                        
                        updateDevelopmentChart();
                    }
                    
                    developmentSvg.select(".zoom-selection").remove();
                    if (!event.shiftKey) {
                        zoomOverlay.style("pointer-events", "none").classed("active", false);
                        overlayActive = false;
                        zoomHint.innerHTML = 'Hold <strong>Shift</strong> and drag to select area to zoom';
                        zoomHint.style.background = 'rgba(102, 126, 234, 0.95)';
                    }
                    zoomRect = null;
                    zoomStartX = null;
                    zoomStartY = null;
                });
            }
        }
        
        function resetZoom() {
            if (originalXScale && originalYScale) {
                document.getElementById('zoomHint').classList.remove('active');
                
                currentXScale.domain(originalXScale.domain());
                currentYScale.domain(originalYScale.domain());
                currentSection = 'all';
                showSection('all');
            }
        }

        // File upload handler
        document.getElementById('csvFile').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const fileName = file.name;
                document.getElementById('fileName').textContent = `Selected: ${fileName}`;
                document.getElementById('fileLabel').classList.add('has-file');
                document.getElementById('fileLabel').textContent = '‚úì File Selected';
                document.getElementById('uploadSection').classList.add('has-data');
                
                document.getElementById('loading').classList.add('active');
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const text = e.target.result;
                        raceData = parseCSV(text);
                        processedData = processRaceData(raceData);
                        
                        document.getElementById('loading').classList.remove('active');
                        document.getElementById('resultsSection').style.display = 'block';
                        
                        displayStats(processedData);
                        
                        const countries = new Set();
                        processedData.forEach(athlete => {
                            developmentAthleteVisibility[athlete.name] = true;
                            spiderAthleteVisibility[athlete.name] = athlete.position <= 5;
                            countries.add(athlete.country);
                        });
                        
                        countries.forEach(country => {
                            developmentCountryVisibility[country] = true;
                        });
                        
                        findSegmentLeaders(processedData);
                        
                        createColorScale(processedData);
                        drawRankChart(processedData);
                        drawDevelopmentChart(processedData);
                        drawSpiderChart(processedData);
                        
                        if (isMobile) {
                            setTimeout(setupMobileCharts, 100);
                        }
                        
                        populateSidebar('summary');
                        
                    } catch (error) {
                        console.error('Error processing file:', error);
                        document.getElementById('errorMessage').textContent = 'Error processing file: ' + error.message;
                        document.getElementById('errorMessage').style.display = 'block';
                        document.getElementById('loading').classList.remove('active');
                    }
                };
                reader.readAsText(file);
            }
        });

        function parseCSV(text) {
            const lines = text.split('\n');
            const headers = lines[0].split(',').map(h => h.trim());
            const data = [];
            
            for (let i = 1; i < lines.length; i++) {
                if (lines[i].trim() === '') continue;
                const values = lines[i].split(',');
                const row = {};
                headers.forEach((header, index) => {
                    row[header] = values[index] ? values[index].trim() : '';
                });
                data.push(row);
            }
            
            return data;
        }

        function timeToSeconds(timeStr) {
            if (!timeStr || timeStr === '' || timeStr === 'DNF' || timeStr === 'DSQ') return null;
            const parts = timeStr.split(':');
            if (parts.length !== 3) return null;
            return parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseInt(parts[2]);
        }

        function secondsToTime(seconds) {
            if (seconds === null || seconds === undefined) return '';
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            if (hours > 0) {
                return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            } else {
                return `${minutes}:${secs.toString().padStart(2, '0')}`;
            }
        }

        function secondsToMinSec(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            if (seconds >= 3600) {
                const hours = Math.floor(seconds / 3600);
                const mins = Math.floor((seconds % 3600) / 60);
                return `${hours}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            return `${minutes}:${secs.toString().padStart(2, '0')}`;
        }
        function adjustToLeaderAtEachStage(processed) {
            // Model A: excludes DNFs from race
            // For each stage, find the leader (minimum cumulative time)
            // const swimLeaderTime = Math.min(...processed.filter(a => a.actualSwimTime).map(a => a.swimCumulative));
            // const t1LeaderTime = Math.min(...processed.filter(a => a.actualT1Time).map(a => a.t1Cumulative));
            // const bikeLeaderTime = Math.min(...processed.filter(a => a.actualBikeTime).map(a => a.bikeCumulative));
            // const t2LeaderTime = Math.min(...processed.filter(a => a.actualT2Time).map(a => a.t2Cumulative));
            // const runLeaderTime = Math.min(...processed.filter(a => a.actualRunTime).map(a => a.totalCumulative));
            
            // // Adjust all times relative to leader at each stage
            // processed.forEach(athlete => {
            //     athlete.swimRelative = athlete.swimCumulative - swimLeaderTime;
            //     athlete.t1Relative = athlete.t1Cumulative - t1LeaderTime;
            //     athlete.bikeRelative = athlete.bikeCumulative - bikeLeaderTime;
            //     athlete.t2Relative = athlete.t2Cumulative - t2LeaderTime;
            //     athlete.runRelative = athlete.totalCumulative - runLeaderTime;
            // });

            // Model B: inludes DNFs from race
            const swimLeader = Math.min(...processed.map(a => a.swimCumulative));
            const t1Leader = Math.min(...processed.map(a => a.t1Cumulative));
            const bikeLeader = Math.min(...processed.map(a => a.bikeCumulative));
            const t2Leader = Math.min(...processed.map(a => a.t2Cumulative));
            const runLeader = Math.min(...processed.map(a => a.totalCumulative));

            // Calculate time behind leader at each stage
            processed.forEach(athlete => {
                athlete.swimGap = athlete.swimCumulative - swimLeader;
                athlete.t1Gap = athlete.t1Cumulative - t1Leader;
                athlete.bikeGap = athlete.bikeCumulative - bikeLeader;
                athlete.t2Gap = athlete.t2Cumulative - t2Leader;
                athlete.runGap = athlete.totalCumulative - runLeader;
            });
        }

        function processRaceData(data) {
            const processed = [];
            
            data.forEach((athlete, index) => {
                const swimTime = timeToSeconds(athlete.Swim);
                const t1Time = timeToSeconds(athlete.T1);
                const bikeTime = timeToSeconds(athlete.Bike);
                const t2Time = timeToSeconds(athlete.T2);
                const runTime = timeToSeconds(athlete.Run);
                const totalTime = timeToSeconds(athlete['Total Time']);
                const status = athlete.Status || '';
                
                let displayName;
                let baseName;
                if (athlete['Athlete First Name'] && athlete['Athlete Last Name']) {
                    displayName = `${athlete['Athlete First Name']} ${athlete['Athlete Last Name']}`;
                    baseName = displayName;
                } else if (athlete.Name) {
                    displayName = athlete.Name;
                    baseName = athlete.Name;
                } else {
                    return;
                }
                
                const penaltyTime = 99 * 3600;
                let processedAthlete = {
                    name: displayName,
                    baseName: baseName,
                    country: athlete.Country,
                    position: athlete.Position ? parseInt(athlete.Position) : null,
                    status: status,
                    swimTime: swimTime || (status === 'DNS' ? penaltyTime : 0),
                    t1Time: t1Time || (status === 'DNS' ? penaltyTime : 0),
                    bikeTime: bikeTime || penaltyTime,
                    t2Time: t2Time || penaltyTime,
                    runTime: runTime || penaltyTime,
                    actualSwimTime: swimTime,
                    actualT1Time: t1Time,
                    actualBikeTime: bikeTime,
                    actualT2Time: t2Time,
                    actualRunTime: runTime
                };
                
                processedAthlete.swimCumulative = processedAthlete.swimTime;
                processedAthlete.t1Cumulative = processedAthlete.swimCumulative + processedAthlete.t1Time;
                processedAthlete.bikeCumulative = processedAthlete.t1Cumulative + processedAthlete.bikeTime;
                processedAthlete.t2Cumulative = processedAthlete.bikeCumulative + processedAthlete.t2Time;
                processedAthlete.totalCumulative = processedAthlete.t2Cumulative + processedAthlete.runTime;
                processedAthlete.actualTotalTime = totalTime;
                
                processed.push(processedAthlete);
            });
            
            const dnsAthletes = processed.filter(a => a.status === 'DNS');
            dnsAthletes.sort((a, b) => a.baseName.localeCompare(b.baseName));
            
            processed.sort((a, b) => a.totalCumulative - b.totalCumulative);
            
            let currentRank = 1;
            processed.forEach((athlete, index) => {
                if (athlete.status === 'DSQ' || athlete.status === 'DNF' || 
                    athlete.status === 'LAP' || athlete.status === 'DNS') {
                    athlete.finalRank = null;
                } else {
                    athlete.finalRank = currentRank++;
                }
            });
            
            processed.forEach((athlete, index) => {
                if (athlete.actualSwimTime) {
                    const fasterSwimmers = processed.filter(a => a.actualSwimTime && a.swimCumulative < athlete.swimCumulative).length;
                    const sameTimbetterFinish = processed.filter(a => 
                        a.actualSwimTime && 
                        a.swimCumulative === athlete.swimCumulative && 
                        a.totalCumulative < athlete.totalCumulative
                    ).length;
                    athlete.swimRank = fasterSwimmers + sameTimbetterFinish + 1;
                } else {
                    athlete.swimRank = index + 1;
                }
                
                if (athlete.actualT1Time) {
                    athlete.t1Rank = processed.filter(a => a.t1Cumulative < athlete.t1Cumulative).length + 1;
                } else {
                    athlete.t1Rank = index + 1;
                }
                
                if (athlete.actualBikeTime) {
                    athlete.bikeRank = processed.filter(a => a.bikeCumulative < athlete.bikeCumulative).length + 1;
                } else {
                    athlete.bikeRank = index + 1;
                }
                
                if (athlete.actualT2Time) {
                    athlete.t2Rank = processed.filter(a => a.t2Cumulative < athlete.t2Cumulative).length + 1;
                } else {
                    athlete.t2Rank = index + 1;
                }
                
                const finishers = processed.filter(a => !['DNF', 'DSQ', 'LAP', 'DNS'].includes(a.status));
                
                if (athlete.actualSwimTime) {
                    athlete.swimSegmentRank = finishers.filter(a => a.actualSwimTime && a.actualSwimTime < athlete.actualSwimTime).length + 1;
                }
                if (athlete.actualT1Time) {
                    athlete.t1SegmentRank = finishers.filter(a => a.actualT1Time && a.actualT1Time < athlete.actualT1Time).length + 1;
                }
                if (athlete.actualBikeTime) {
                    athlete.bikeSegmentRank = finishers.filter(a => a.actualBikeTime && a.actualBikeTime < athlete.actualBikeTime).length + 1;
                }
                if (athlete.actualT2Time) {
                    athlete.t2SegmentRank = finishers.filter(a => a.actualT2Time && a.actualT2Time < athlete.actualT2Time).length + 1;
                }
                if (athlete.actualRunTime) {
                    athlete.runSegmentRank = finishers.filter(a => a.actualRunTime && a.actualRunTime < athlete.actualRunTime).length + 1;
                }
            });
            adjustToLeaderAtEachStage(processed);
            return processed;
        }

        function findSegmentLeaders(data) {
            const finishers = data.filter(a => !['DNF', 'DSQ', 'LAP', 'DNS'].includes(a.status) && a.actualSwimTime);
            
            if (finishers.length > 0) {
                segmentLeaders.swim = finishers.reduce((min, athlete) => 
                    (athlete.actualSwimTime && athlete.actualSwimTime < min.actualSwimTime) ? athlete : min, finishers[0]);
                segmentLeaders.t1 = finishers.reduce((min, athlete) => 
                    (athlete.actualT1Time && athlete.actualT1Time < min.actualT1Time) ? athlete : min, finishers[0]);
                segmentLeaders.bike = finishers.reduce((min, athlete) => 
                    (athlete.actualBikeTime && athlete.actualBikeTime < min.actualBikeTime) ? athlete : min, finishers[0]);
                segmentLeaders.t2 = finishers.reduce((min, athlete) => 
                    (athlete.actualT2Time && athlete.actualT2Time < min.actualT2Time) ? athlete : min, finishers[0]);
                segmentLeaders.run = finishers.reduce((min, athlete) => 
                    (athlete.actualRunTime && athlete.actualRunTime < min.actualRunTime) ? athlete : min, finishers[0]);
            }
        }

        function displayStats(data) {
            const statsHTML = ``;
            document.getElementById('statsSummary').innerHTML = statsHTML;
            
            displayFinishersData(data);
            displayTopPerformances(data);
        }
        
        function displayFinishersData(data) {
            const finishers = data.filter(a => !['DNF', 'DSQ', 'LAP', 'DNS'].includes(a.status));
            const starters = data.filter(a => a.status !== 'DNS');
            const avgSwim = d3.mean(finishers, d => d.actualSwimTime || 0);
            const avgBike = d3.mean(finishers, d => d.actualBikeTime || 0);
            const avgRun = d3.mean(finishers, d => d.actualRunTime || 0);
            
            const winner = finishers.find(a => a.finalRank === 1);
            const winnerTime = winner ? winner.actualTotalTime : 0;
            
            const finishersHTML = `
                <div class="stat-item">
                    <div class="stat-value">${finishers.length}/${starters.length}</div>
                    <div class="stat-label">Finishers/Starters</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${secondsToMinSec(avgSwim)}</div>
                    <div class="stat-label">Avg Swim</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${secondsToMinSec(avgBike)}</div>
                    <div class="stat-label">Avg Bike</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${secondsToMinSec(avgRun)}</div>
                    <div class="stat-label">Avg Run</div>
                </div>
            `;
            
            const finishersContainer = document.getElementById('finishersData');
            if (finishersContainer) {
                finishersContainer.innerHTML = finishersHTML;
            }
        }
        
        function displayTopPerformances(data) {
            const container = document.getElementById('topPerformances');
            if (!container) return;
            
            container.innerHTML = '<h2 style="margin-bottom: 20px;">Top 3 Performances</h2>';
            
            const finishers = data.filter(a => !['DNF', 'DSQ', 'LAP', 'DNS'].includes(a.status));
            
            const top3Overall = finishers
                .sort((a, b) => (a.finalRank || 999) - (b.finalRank || 999))
                .slice(0, 3);
            
            let html = '<div style="background: #f8f9fa; padding: 15px; border-radius: 10px; margin-bottom: 20px;">';
            html += '<h3 style="color: #667eea; margin-bottom: 10px;">üèÜ Overall</h3>';
            top3Overall.forEach((athlete, i) => {
                const totalTime = athlete.actualTotalTime || 0;
                html += `<div style="display: flex; justify-content: space-between; padding: 8px; background: white; border-radius: 5px; margin-bottom: 5px;">
                    <span><strong>${i + 1}.</strong> ${athlete.baseName} (${athlete.country})</span>
                    <strong>${secondsToTime(totalTime)}</strong>
                </div>`;
            });
            html += '</div>';
            
            const segments = [
                { name: 'Swim', key: 'actualSwimTime', icon: 'üèä' },
                { name: 'Bike', key: 'actualBikeTime', icon: 'üö¥' },
                { name: 'Run', key: 'actualRunTime', icon: 'üèÉ' }
            ];
            
            segments.forEach(segment => {
                const validAthletes = finishers.filter(a => a[segment.key] && a[segment.key] > 0);
                const top3 = validAthletes
                    .sort((a, b) => a[segment.key] - b[segment.key])
                    .slice(0, 3);
                
                html += '<div style="background: #f8f9fa; padding: 15px; border-radius: 10px; margin-bottom: 20px;">';
                html += `<h3 style="color: #667eea; margin-bottom: 10px;">${segment.icon} Best ${segment.name} Times</h3>`;
                top3.forEach((athlete, i) => {
                    html += `<div style="display: flex; justify-content: space-between; padding: 8px; background: white; border-radius: 5px; margin-bottom: 5px;">
                        <span><strong>${i + 1}.</strong> ${athlete.baseName} (${athlete.country})</span>
                        <strong>${secondsToMinSec(athlete[segment.key])}</strong>
                    </div>`;
                });
                html += '</div>';
            });
            
            container.innerHTML += html;
        }

        function openRaceConfigDialog() {
            document.getElementById('swimDistance').value = raceConfig.swim;
            document.getElementById('bikeDistance').value = raceConfig.bike;
            document.getElementById('runDistance').value = raceConfig.run;
            document.getElementById('raceConfigDialog').style.display = 'flex';
        }

        function closeRaceConfigDialog() {
            document.getElementById('raceConfigDialog').style.display = 'none';
        }

        function setRaceType() {
            const type = document.getElementById('raceTypeSelect').value;
            if (type === 'standard') {
                document.getElementById('swimDistance').value = 1500;
                document.getElementById('bikeDistance').value = 40;
                document.getElementById('runDistance').value = 10;
            } else if (type === 'sprint') {
                document.getElementById('swimDistance').value = 750;
                document.getElementById('bikeDistance').value = 20;
                document.getElementById('runDistance').value = 5;
            }
        }

        function saveRaceConfig() {
            raceConfig.swim = parseFloat(document.getElementById('swimDistance').value);
            raceConfig.bike = parseFloat(document.getElementById('bikeDistance').value);
            raceConfig.run = parseFloat(document.getElementById('runDistance').value);
            closeRaceConfigDialog();
            
            // Recalculate all paces if hypothetical dialog is open
            if (document.getElementById('hypotheticalDialog').style.display === 'flex') {
                updatePaceInfo();
                updateBikeProjection();
                updateRunImpact();
                updateScenarioResults();
            }
            // Refresh current chart if spider is active to show new paces in tooltips
            const activeTab = document.querySelector('.tab-btn.active');
            if (activeTab && activeTab.textContent.includes('Spider')) {
                updateSpiderChart();
            }
        }

        function createColorScale(data) {
            const colors = [
                '#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00',
                '#a65628', '#f781bf', '#999999', '#66c2a5', '#fc8d62',
                '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494',
                '#b3b3b3', '#1b9e77', '#d95f02', '#7570b3', '#e7298a',
                '#66a61e', '#e6ab02', '#a6761d', '#666666'
            ];
            
            while (colors.length < data.length) {
                colors.push(`hsl(${Math.random() * 360}, 70%, 50%)`);
            }
            
            colorScale = d3.scaleOrdinal()
                .domain(data.map(d => d.name))
                .range(colors);
        }

        function drawRankChart(data) {
            d3.select("#rankChart").selectAll("*").remove();
            
            const dsqAthletes = data.filter(a => a.status === 'DSQ')
                .sort((a, b) => {
                    const aTime = (a.actualSwimTime || 0) + (a.actualT1Time || 0) + 
                                 (a.actualBikeTime || 0) + (a.actualT2Time || 0) + (a.actualRunTime || 0);
                    const bTime = (b.actualSwimTime || 0) + (b.actualT1Time || 0) + 
                                 (b.actualBikeTime || 0) + (b.actualT2Time || 0) + (b.actualRunTime || 0);
                    return aTime - bTime;
                });
            const nonDsqData = data.filter(a => a.status !== 'DSQ');
            
            const containerWidth = document.getElementById('rankChart').parentElement.offsetWidth || window.innerWidth - 40;
            const containerHeight = window.innerHeight * 0.9; // Use 90% of viewport height

            const margin = {
                top: isMobile ? 20 : 30,
                right: Math.max(120, containerWidth * 0.2), 
                bottom: isMobile ? 40 : 60,
                left: isMobile ? 40 : 60
            };

            const availableWidth = containerWidth - 40;
            const width = availableWidth - margin.left - margin.right;
            const minHeight = 400;
            const rowHeight = isMobile ? 12 : 15;
            const height = Math.max(minHeight, data.length * rowHeight) - margin.top - margin.bottom;

            const svg = d3.select("#rankChart")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            const finishers = data.filter(a => !['DNF', 'DSQ', 'LAP', 'DNS'].includes(a.status));
            const avgSwim = d3.mean(finishers, d => d.actualSwimTime || 0);
            const avgT1 = d3.mean(finishers, d => d.actualT1Time || 0);
            const avgBike = d3.mean(finishers, d => d.actualBikeTime || 0);
            const avgT2 = d3.mean(finishers, d => d.actualT2Time || 0);
            const avgRun = d3.mean(finishers, d => d.actualRunTime || 0);
            
            const t1Boost = avgT1 * 4;
            const t2Boost = avgT2 * 4;
            const totalBoost = t1Boost + t2Boost;
            
            const swimProp = avgSwim / (avgSwim + avgBike + avgRun);
            const bikeProp = avgBike / (avgSwim + avgBike + avgRun);
            const runProp = avgRun / (avgSwim + avgBike + avgRun);
            
            const adjustedSwim = avgSwim - (totalBoost * swimProp);
            const adjustedBike = avgBike - (totalBoost * bikeProp);
            const adjustedRun = avgRun - (totalBoost * runProp);
            const adjustedT1 = avgT1 * 5;
            const adjustedT2 = avgT2 * 5;
            
            const adjustedTotal = adjustedSwim + adjustedT1 + adjustedBike + adjustedT2 + adjustedRun;
            
            const swimEnd = adjustedSwim / adjustedTotal;
            const t1End = (adjustedSwim + adjustedT1) / adjustedTotal;
            const bikeEnd = (adjustedSwim + adjustedT1 + adjustedBike) / adjustedTotal;
            const t2End = (adjustedSwim + adjustedT1 + adjustedBike + adjustedT2) / adjustedTotal;
            
            const stages = [
                {name: "Start", key: "swimRank", position: 0},
                {name: "Swim", key: "swimRank", position: swimEnd},
                {name: "T1", key: "t1Rank", position: t1End},
                {name: "Bike", key: "bikeRank", position: bikeEnd},
                {name: "T2", key: "t2Rank", position: t2End},
                {name: "Finish", key: "finalRank", position: 1}
            ];
            
            const xScale = d3.scaleLinear()
                .domain([0, 1])
                .range([0, width]);
            
            const dsqCount = dsqAthletes.length;
            const totalPositions = data.length + dsqCount;
            const yScale = d3.scaleLinear()
                .domain([1, totalPositions + 1])
                .range([0, height]);
            
            chartConfig.setupAxes(svg, xScale, yScale, height, width, null, "Position");
            
            const xAxis = svg.select('.x-axis');
            xAxis.call(d3.axisBottom(xScale)
                .tickValues(stages.map(s => s.position))
                .tickFormat("")
            );
            
            const xLabels = [
                { pos: (0 + swimEnd) / 2, text: 'Swim' },
                { pos: (swimEnd + t1End) / 2, text: 'T1' },
                { pos: (t1End + bikeEnd) / 2, text: 'Bike' },
                { pos: (bikeEnd + t2End) / 2, text: 'T2' },
                { pos: (t2End + 1) / 2, text: 'Run' }
            ];
            
            xLabels.forEach(label => {
                xAxis.append("text")
                    .attr("x", xScale(label.pos))
                    .attr("y", 30)
                    .style("text-anchor", "middle")
                    .style("font-size", "12px")
                    .style("fill", "black")
                    .text(label.text);
            });
            const transitionLines = svg.append("g")
                .attr("class", "transition-lines");

            const transitionPositions = [
                { x: swimEnd, label: 'Swim End' },
                { x: t1End, label: 'T1 End' },
                { x: bikeEnd, label: 'Bike End' },
                { x: t2End, label: 'T2 End' }
            ];

            transitionPositions.forEach(trans => {
                transitionLines.append("line")
                    .attr("x1", xScale(trans.x))
                    .attr("x2", xScale(trans.x))
                    .attr("y1", 0)
                    .attr("y2", height)
                    .attr("stroke", "#e0e0e0")
                    .attr("stroke-width", 1)
                    .attr("stroke-dasharray", "3,3")
                    .attr("opacity", 0.5);
            });            
            let dnfPosition = Math.max(...data.filter(a => a.finalRank).map(a => a.finalRank || 0)) + 1;
            const athletePositions = {};
            
            data.forEach((athlete, index) => {
                if (athlete.finalRank) {
                    athletePositions[athlete.name] = athlete.finalRank;
                } else if (athlete.status === 'DSQ') {
                    const dsqIndex = dsqAthletes.indexOf(athlete);
                    athletePositions[athlete.name] = nonDsqData.length + dsqIndex + 1;
                } else {
                    athletePositions[athlete.name] = dnfPosition++;
                }
            });
            
            data.forEach((athlete, athleteIndex) => {
                const finalPosition = athletePositions[athlete.name];
                const lineData = stages.map(stage => {
                    let rank;
                    if (stage.key === 'finalRank') {
                        rank = finalPosition;
                    } else {
                        rank = athlete[stage.key] || finalPosition;
                    }
                    return { x: stage.position, y: rank };
                });
                
                const athleteGroup = svg.append("g")
                    .attr("class", `athlete-group-${athleteIndex}`)
                    .attr("pointer-events", "all");
                
                let strokeDasharray = "";
                if (athlete.status === 'DSQ') {
                    strokeDasharray = "3,3";
                } else if (athlete.status === 'DNF' || athlete.status === 'LAP') {
                    strokeDasharray = "8,4";
                } else if (athlete.status === 'DNS') {
                    strokeDasharray = "8,4";
                }
                
                for (let i = 0; i < lineData.length - 1; i++) {
                    // Add invisible wider line for better hover detection
                    athleteGroup.append("line")
                        .attr("class", "athlete-line-hitarea")
                        .attr("x1", xScale(lineData[i].x))
                        .attr("y1", yScale(lineData[i].y))
                        .attr("x2", xScale(lineData[i + 1].x))
                        .attr("y2", yScale(lineData[i + 1].y))
                        .attr("stroke", "transparent")
                        .attr("stroke-width", 10)  // Much wider for easier hovering
                        .attr("pointer-events", "stroke");
                    
                    // Add visible line
                    athleteGroup.append("line")
                        .attr("class", "athlete-line")
                        .attr("x1", xScale(lineData[i].x))
                        .attr("y1", yScale(lineData[i].y))
                        .attr("x2", xScale(lineData[i + 1].x))
                        .attr("y2", yScale(lineData[i + 1].y))
                        .attr("stroke", colorScale(athlete.name))
                        .attr("stroke-width", 1.5)
                        .attr("stroke-dasharray", strokeDasharray)
                        .attr("opacity", 0.4)
                        .attr("pointer-events", "none");  // Don't capture events on visible line
                }
                
                athleteGroup.on("mouseover", function(event) {
                    // Highlight all lines in this group
                    d3.select(this).selectAll(".athlete-line")
                        .style("stroke-width", "3px")
                        .style("opacity", "1");
                    
                    const tooltip = d3.select("#tooltip");
                    tooltip.transition().duration(200).style("opacity", .9);
                    
                    const finishTime = athlete.actualTotalTime || 0;
                    
                    const leader = data.find(d => d.finalRank === 1);
                    const leaderFinishTime = leader ? leader.actualTotalTime : finishTime;
                    const timeBehind = finishTime - leaderFinishTime;
                    
                    const athleteName = athlete.baseName || athlete.name.replace(/ \([^)]*\)$/, '');
                    
                    let tooltipContent = `<strong>${athleteName} (${athlete.finalRank || 'N/A'}) ${athlete.country}</strong><br/>`;
                    if (athlete.actualSwimTime) {
                        tooltipContent += `Swim: ${secondsToTime(athlete.actualSwimTime)} (${athlete.swimSegmentRank || 'N/A'})<br/>`;
                    }
                    if (athlete.actualT1Time) {
                        tooltipContent += `T1: ${secondsToTime(athlete.actualT1Time)} (${athlete.t1SegmentRank || 'N/A'})<br/>`;
                    }
                    if (athlete.actualBikeTime) {
                        tooltipContent += `Bike: ${secondsToTime(athlete.actualBikeTime)} (${athlete.bikeSegmentRank || 'N/A'})<br/>`;
                    } else if (athlete.status === 'DNF' || athlete.status === 'LAP') {
                        tooltipContent += `Bike: DNF<br/>`;
                    }
                    if (athlete.actualT2Time) {
                        tooltipContent += `T2: ${secondsToTime(athlete.actualT2Time)} (${athlete.t2SegmentRank || 'N/A'})<br/>`;
                    }
                    if (athlete.actualRunTime) {
                        tooltipContent += `Run: ${secondsToTime(athlete.actualRunTime)} (${athlete.runSegmentRank || 'N/A'})<br/>`;
                    } else if ((athlete.status === 'DNF' || athlete.status === 'LAP') && athlete.actualBikeTime) {
                        tooltipContent += `Run: DNF<br/>`;
                    }
                    
                    if (athlete.status && athlete.status !== 'OK') {
                        tooltipContent += `<hr style="margin: 5px 0; border: 0; border-top: 1px solid rgba(255,255,255,0.3);">`;
                        tooltipContent += `Status: ${athlete.status}`;
                    } else {
                        tooltipContent += `<hr style="margin: 5px 0; border: 0; border-top: 1px solid rgba(255,255,255,0.3);">`;
                        tooltipContent += `Total: ${secondsToTime(finishTime)} ${timeBehind === 0 ? '(Leader)' : '(+' + secondsToTime(timeBehind) + ')'}`;
                    }
                    
                    tooltip.html(tooltipContent)
                    .style("left", (window.innerWidth - 250) + "px")
                    .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function() {
                    d3.select(this).selectAll(".athlete-line")
                        .style("stroke-width", "1.5px")
                        .style("opacity", "0.4");
                    
                    d3.select("#tooltip").transition()
                        .duration(500)
                        .style("opacity", 0);
                });
            });
            
            let nonFinisherPosition = Math.max(...nonDsqData.filter(a => a.finalRank).map(a => a.finalRank || 0)) + 1;
            
            nonDsqData.forEach((athlete, index) => {
                let displayY;
                if (athlete.finalRank) {
                    displayY = yScale(athlete.finalRank);
                } else {
                    displayY = yScale(nonFinisherPosition++);
                }
                let displayText = '';
                
                const baseName = athlete.baseName || athlete.name.replace(/ \([^)]*\)$/, '');
                if (athlete.finalRank) {
                    displayText = `${athlete.finalRank}. ${baseName} ${athlete.country} (${athlete.finalRank})`;
                } else if (athlete.status) {
                    displayText = `${baseName} ${athlete.country} (${athlete.status})`;
                }
                
                svg.append("text")
                    .attr("x", width + 10)
                    .attr("y", displayY)
                    .attr("dy", "0.35em")
                    .style("font-size", "10px")
                    .style("fill", colorScale(athlete.name))
                    .text(displayText);
            });
            
            dsqAthletes.forEach((athlete, index) => {
                const baseName = athlete.baseName || athlete.name.replace(/ \([^)]*\)$/, '');
                const displayText = `${baseName} ${athlete.country} (DSQ)`;
                const displayY = yScale(nonFinisherPosition + index);
                
                svg.append("text")
                    .attr("x", width + 10)
                    .attr("y", displayY)
                    .attr("dy", "0.35em")
                    .style("font-size", "10px")
                    .style("fill", colorScale(athlete.name))
                    .text(displayText);
            });
        }

        function drawDevelopmentChart(data) {
            d3.select("#developmentChart").selectAll("*").remove();
            
            const racers = data.filter(a => a.status !== 'DNS');
            
            const containerWidth = document.getElementById('developmentChart').parentElement.offsetWidth || window.innerWidth - 40;
            const containerHeight = window.innerHeight * 0.7; // Use 70% of viewport height

            const margin = {
                top: isMobile ? 20 : 30,
                right: isMobile ? 10 : 20,
                bottom: isMobile ? 40 : 60,
                left: isMobile ? 50 : 70
            };

            const width = containerWidth - margin.left - margin.right - 40; // 20px padding each side
            const height = containerHeight - margin.top - margin.bottom;

            chartWidth = width;
            chartHeight = height;
            
            developmentSvg = d3.select("#developmentChart")
                            .append("svg")
                            .attr("width", chartWidth + margin.left + margin.right)
                            .attr("height", chartHeight + margin.top + margin.bottom);
            
            developmentSvg.append("defs")
                            .append("clipPath")
                            .attr("id", "chart-clip")
                            .append("rect")
                            .attr("x", 0)
                            .attr("y", 0)
                            .attr("width", chartWidth)
                            .attr("height", chartHeight);
            
            developmentG = developmentSvg.append("g")
                            .attr("transform", `translate(${margin.left},${margin.top})`);
            
            const finishers = racers.filter(a => !['DNF', 'DSQ', 'LAP'].includes(a.status));
            const avgSwim = d3.mean(finishers, d => d.actualSwimTime || 0);
            const avgT1 = d3.mean(finishers, d => d.actualT1Time || 0);
            const avgBike = d3.mean(finishers, d => d.actualBikeTime || 0);
            const avgT2 = d3.mean(finishers, d => d.actualT2Time || 0);
            const avgRun = d3.mean(finishers, d => d.actualRunTime || 0);
            const totalAvg = avgSwim + avgT1 + avgBike + avgT2 + avgRun;
            
            const swimDist = (avgSwim / totalAvg) * 100;
            const t1Dist = swimDist + (avgT1 / totalAvg) * 100;
            const bikeDist = t1Dist + (avgBike / totalAvg) * 100;
            const t2Dist = bikeDist + (avgT2 / totalAvg) * 100;
            
            stageDist = {
                swim: swimDist,
                t1: t1Dist,
                bike: bikeDist,
                t2: t2Dist
            };
            
            const t1Width = t1Dist - swimDist;
            const t2Width = t2Dist - bikeDist;
            const t1Center = swimDist + t1Width / 2;
            const t2Center = bikeDist + t2Width / 2;
            const zoomWidth = 5;
            
            sectionBounds = {
                'all': { start: 0, end: 100, type: 'all' },
                'swim': { start: 0, end: t1Dist, type: 'swim' },
                't1': { start: Math.max(0, t1Center - zoomWidth/2), end: Math.min(100, t1Center + zoomWidth/2), type: 'transition' },
                'bike': { start: t1Dist, end: t2Dist, type: 'bike' },
                't2': { start: Math.max(0, t2Center - zoomWidth/2), end: Math.min(100, t2Center + zoomWidth/2), type: 'transition' },
                'run': { start: bikeDist, end: 100, type: 'run' }
            };
            
            const leader = finishers[0];
            developmentChartData = racers.map(athlete => {
                const values = [{stage: "Start", distance: 0, timeBehind: 0, cumTime: 0}];
                
                if (athlete.actualSwimTime) {
                    values.push({
                        stage: "Swim",
                        distance: swimDist,
                        timeBehind: athlete.swimCumulative - leader.swimCumulative,
                        cumTime: athlete.swimCumulative
                    });
                }
                if (athlete.actualT1Time) {
                    values.push({
                        stage: "T1",
                        distance: t1Dist,
                        timeBehind: athlete.t1Cumulative - leader.t1Cumulative,
                        cumTime: athlete.t1Cumulative
                    });
                }
                if (athlete.actualBikeTime) {
                    values.push({
                        stage: "Bike",
                        distance: bikeDist,
                        timeBehind: athlete.bikeCumulative - leader.bikeCumulative,
                        cumTime: athlete.bikeCumulative
                    });
                }
                if (athlete.actualT2Time) {
                    values.push({
                        stage: "T2",
                        distance: t2Dist,
                        timeBehind: athlete.t2Cumulative - leader.t2Cumulative,
                        cumTime: athlete.t2Cumulative
                    });
                }
                if (athlete.actualRunTime) {
                    values.push({
                        stage: "Finish",
                        distance: 100,
                        timeBehind: athlete.totalCumulative - leader.totalCumulative,
                        cumTime: athlete.totalCumulative
                    });
                }
                return {
                    name: athlete.name,
                    country: athlete.country,
                    athleteIndex: racers.indexOf(athlete),
                    athlete: athlete,
                    status: athlete.status,
                    values: values
                };
            });
            
            const maxTimeBehind = d3.max(developmentChartData, d => d3.max(d.values, v => v.timeBehind));
            
            originalXScale = d3.scaleLinear()
                            .domain([0, 100])
                            .range([0, chartWidth]);
            
            originalYScale = d3.scaleLinear()
                            .domain([-maxTimeBehind - 10, 10])
                            .range([chartHeight, 0]);
            
            currentXScale = originalXScale.copy();
            currentYScale = originalYScale.copy();
            
            lineGenerator = d3.line()
                            .x(d => currentXScale(d.distance))
                            .y(d => currentYScale(-d.timeBehind))
                            .curve(d3.curveLinear);
            
            chartConfig.setupAxes(developmentG, currentXScale, currentYScale, chartHeight, chartWidth, "Race Progress", "Time Behind Leader (mins)");
            
            const transitionLines = developmentG.append("g")
                            .attr("class", "transition-lines");
            
            const transitionPositions = [
                { x: swimDist, class: 'transition-line-t1-start' },
                { x: t1Dist, class: 'transition-line-t1-end' },
                { x: bikeDist, class: 'transition-line-t2-start' },
                { x: t2Dist, class: 'transition-line-t2-end' }
            ];
            
            transitionPositions.forEach(trans => {
                transitionLines.append("line")
                    .attr("class", trans.class)
                    .attr("x1", currentXScale(trans.x))
                    .attr("x2", currentXScale(trans.x))
                    .attr("y1", 0)
                    .attr("y2", chartHeight)
                    .attr("stroke", "#e0e0e0")
                    .attr("stroke-width", 1)
                    .attr("stroke-dasharray", "3,3")
                    .attr("opacity", 0.8);
            });
            
            developmentG.select(".x-axis")
                .call(d3.axisBottom(currentXScale)
                    .tickValues([0, swimDist, t1Dist, bikeDist, t2Dist, 100])
                    .tickFormat("")
                );
            
            const xLabels = developmentG.select('.x-axis').append("g").attr("class", "x-labels");
            const labels = [
                { x: swimDist / 2, text: 'Swim', class: 'x-label-swim' },
                { x: (swimDist + t1Dist) / 2, text: 'T1', class: 'x-label-t1' },
                { x: (t1Dist + bikeDist) / 2, text: 'Bike', class: 'x-label-bike' },
                { x: (bikeDist + t2Dist) / 2, text: 'T2', class: 'x-label-t2' },
                { x: (t2Dist + 100) / 2, text: 'Run', class: 'x-label-run' }
            ];
            
            labels.forEach(label => {
                xLabels.append("text")
                    .attr("class", label.class)
                    .attr("x", currentXScale(label.x))
                    .attr("y", 30)
                    .style("text-anchor", "middle")
                    .style("font-size", "12px")
                    .style("fill", "black")
                    .text(label.text);
            });
            
            developmentG.select('.y-axis')
                .call(d3.axisLeft(currentYScale)
                    .tickFormat(d => {
                        const absD = Math.abs(d);
                        if (isMobile) {
                            const mins = Math.floor(absD / 60);
                            return mins.toString();
                        } else {
                            return secondsToTime(absD);
                        }
                    })
                    .ticks(isMobile ? 3 : undefined)
                );
            
            const chartContent = developmentG.append("g")
                            .attr("class", "chart-content")
                            .attr("clip-path", "url(#chart-clip)");
            
            developmentChartData.forEach((athlete, index) => {
                // Check if athlete should be visible
                const isVisible = developmentAthleteVisibility[athlete.name] !== false;
                
                let strokeDasharray = "";
                if (athlete.status === 'DSQ') {
                    strokeDasharray = "3,3";
                } else if (athlete.status === 'DNF' || athlete.status === 'LAP') {
                    strokeDasharray = "8,4";
                }
                
                // Add invisible wider path for better hover detection
                const hitArea = chartContent.append("path")
                    .datum(athlete.values)
                    .attr("class", `athlete-path-hitarea athlete-path-hitarea-${athlete.athleteIndex}`)
                    .attr("d", lineGenerator)
                    .attr("fill", "none")
                    .attr("stroke", "transparent")
                    .attr("stroke-width", 10)
                    .attr("pointer-events", "stroke")
                    .classed("hidden", !isVisible); // ADD THIS
                
                // Add visible path
                const path = chartContent.append("path")
                    .datum(athlete.values)
                    .attr("class", `athlete-path athlete-path-${athlete.athleteIndex}`)
                    .attr("d", lineGenerator)
                    .attr("fill", "none")
                    .attr("stroke", colorScale(athlete.name))
                    .attr("stroke-dasharray", strokeDasharray)
                    .attr("pointer-events", "none")
                    .classed("hidden", !isVisible); // ADD THIS
        
                // Attach events to the hitArea instead
                hitArea.on("mouseover", function(event) {
                        d3.selectAll(`.athlete-path-${athlete.athleteIndex}`)
                            .style("stroke-width", "3px")
                            .style("opacity", "1");
                        d3.selectAll(`.athlete-circle-${athlete.athleteIndex}`)
                            .attr("r", 5)
                            .attr("opacity", 1);
                        
                        const tooltip = d3.select("#tooltip");
                        tooltip.transition().duration(200).style("opacity", .9);
                        const athleteName = athlete.athlete.baseName || athlete.name.replace(/ \([^)]*\)$/, '');
                        const finishTime = athlete.athlete.actualTotalTime || 0;
                        const timeDiff = Math.abs(athlete.values[athlete.values.length - 1].timeBehind);
                        tooltip.html(`
                            <strong>${athleteName} (${athlete.athlete.finalRank || 'N/A'}) ${athlete.athlete.country}</strong><br/>
                            Finish Time: ${secondsToTime(finishTime)}<br/>
                            ${timeDiff > 0 ? `Behind Leader: ${secondsToTime(timeDiff)}` : 'Race Leader'}
                        `)
                        .style("left", (window.innerWidth - 250) + "px")
                        .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function() {
                        d3.selectAll(`.athlete-path-${athlete.athleteIndex}`)
                            .style("stroke-width", "1.5px")
                            .style("opacity", "0.4");
                        d3.selectAll(`.athlete-circle-${athlete.athleteIndex}`)
                            .attr("r", 4)
                            .attr("opacity", 0.8);
                        d3.select("#tooltip").transition()
                            .duration(500)
                            .style("opacity", 0);
                    });
                
                if (isMobile) {
                    let tapTimeout;
                    hitArea.on("touchstart", function(event) {
                        event.preventDefault();
                        const touch = event.touches[0];
                        if (tapTimeout) clearTimeout(tapTimeout);
                        
                        tapTimeout = setTimeout(() => {
                            const tooltip = d3.select("#tooltip");
                            tooltip.style("opacity", .9);
                            const athleteName = athlete.athlete.baseName || athlete.name.replace(/ \([^)]*\)$/, '');
                            tooltip.html(`<strong>${athleteName}</strong><br/>${athlete.athlete.country}`)
                                .style("left", (touch.pageX + 10) + "px")
                                .style("top", (touch.pageY - 28) + "px");
                            setTimeout(() => tooltip.style("opacity", 0), 3000);
                        }, 500);
                    })
                    .on("touchend", function(event) {
                        event.preventDefault();
                        if (tapTimeout) {
                            clearTimeout(tapTimeout);
                            d3.selectAll(".athlete-path").style("opacity", "0.1");
                            d3.selectAll(`.athlete-path-${athlete.athleteIndex}`).style("opacity", "1").style("stroke-width", "3px");
                            setTimeout(() => {
                                d3.selectAll(".athlete-path").style("opacity", "0.4").style("stroke-width", "1.5px");
                            }, 3000);
                        }
                    });
                }       
                athlete.values.forEach((point, i) => {
                    const circle = chartContent.append("circle")
                        .attr("class", `athlete-circle athlete-circle-${athlete.athleteIndex}`)
                        .attr("data-x", point.distance)
                        .attr("data-y", -point.timeBehind)
                        .attr("data-stage", point.stage)
                        .attr("cx", currentXScale(point.distance))
                        .attr("cy", currentYScale(-point.timeBehind))
                        .attr("r", 4)
                        .attr("fill", colorScale(athlete.name))
                        .style("cursor", "pointer")
                        .classed("hidden", !isVisible); // ADD THIS
                    
                    // Add long-press detection for hypothetical analysis
                    let longPressTimer;
                    
                    circle.on("mousedown", function(event) {
                        longPressTimer = setTimeout(() => {
                            openHypotheticalDialog(athlete.athlete, point.stage);
                        }, 500); // 500ms for long press
                    })
                    .on("mouseup mouseleave", function() {
                        if (longPressTimer) {
                            clearTimeout(longPressTimer);
                        }
                    })
                    .on("mouseover", function(event) {
                        d3.selectAll(`.athlete-path-${athlete.athleteIndex}`)
                            .attr("stroke-width", 3)
                            .attr("opacity", 1);
                        d3.select(this).attr("r", 6);
                        
                        const tooltip = d3.select("#tooltip");
                        tooltip.transition().duration(200).style("opacity", .9);
                        
                        const athleteName = athlete.athlete.baseName || athlete.name.replace(/ \([^)]*\)$/, '');
                        let tooltipContent = `<strong>${athleteName} (${athlete.athlete.country})</strong><br/>`;
                        tooltipContent += `<strong>Overall: ${athlete.athlete.finalRank || 'N/A'}</strong><br/>`;
                        tooltipContent += `<hr style="margin: 5px 0; border: 0; border-top: 1px solid rgba(255,255,255,0.3);">`;
                        
                        // Calculate race leader at this point
                        const leaderTime = Math.min(...developmentChartData
                            .filter(a => a.values.some(v => v.stage === point.stage))
                            .map(a => {
                                const stageData = a.values.find(v => v.stage === point.stage);
                                return stageData ? stageData.cumTime : Infinity;
                            }));
                        
                        const timeBehindLeader = point.cumTime - leaderTime;
                        
                        // Get percentile information
                        const getPercentile = (value, allValues) => {
                            const sorted = allValues.filter(v => v !== null).sort((a, b) => a - b);
                            const index = sorted.findIndex(v => v >= value);
                            return Math.round((index / sorted.length) * 100);
                        };
                        
                        if (point.stage === 'Swim' && athlete.athlete.actualSwimTime) {
                            const swimPace = (athlete.athlete.actualSwimTime / raceConfig.swim) * 100; // Use raceConfig.swim
                            const allSwimTimes = processedData.map(a => a.actualSwimTime).filter(t => t && t < 99 * 3600);
                            const percentile = getPercentile(athlete.athlete.actualSwimTime, allSwimTimes);
                            
                            tooltipContent += `<strong>End of Swim</strong><br/>`;
                            tooltipContent += `Time: ${secondsToTime(athlete.athlete.actualSwimTime)}<br/>`;
                            tooltipContent += `Pace: ${secondsToTime(swimPace)}/100m<br/>`;
                            tooltipContent += `Segment Rank: ${athlete.athlete.swimSegmentRank}<br/>`;
                            tooltipContent += `Percentile: ${percentile}%<br/>`;
                            tooltipContent += `Behind Leader: ${timeBehindLeader === 0 ? 'Leader' : '+' + secondsToTime(timeBehindLeader)}`;
                            
                        } else if (point.stage === 'Bike' && athlete.athlete.actualBikeTime) {
                            const bikeSpeed = (raceConfig.bike / athlete.athlete.actualBikeTime) * 3600; // Use raceConfig.bike
                            const allBikeTimes = processedData.map(a => a.actualBikeTime).filter(t => t && t < 99 * 3600);
                            const percentile = getPercentile(athlete.athlete.actualBikeTime, allBikeTimes);
                            
                            tooltipContent += `<strong>End of Bike</strong><br/>`;
                            tooltipContent += `Time: ${secondsToTime(athlete.athlete.actualBikeTime)}<br/>`;
                            tooltipContent += `Speed: ${bikeSpeed.toFixed(1)} km/hr<br/>`;
                            tooltipContent += `Segment Rank: ${athlete.athlete.bikeSegmentRank}<br/>`;
                            tooltipContent += `Percentile: ${percentile}%<br/>`;
                            tooltipContent += `Behind Leader: ${timeBehindLeader === 0 ? 'Leader' : '+' + secondsToTime(timeBehindLeader)}`;
                            
                        } else if (point.stage === 'Finish' && athlete.athlete.actualRunTime) {
                            const runPace = athlete.athlete.actualRunTime / raceConfig.run / 60; // Use raceConfig.run
                            const allRunTimes = processedData.map(a => a.actualRunTime).filter(t => t && t < 99 * 3600);
                            const percentile = getPercentile(athlete.athlete.actualRunTime, allRunTimes);
                            
                            tooltipContent += `<strong>End of Run (Finish)</strong><br/>`;
                            tooltipContent += `Time: ${secondsToTime(athlete.athlete.actualRunTime)}<br/>`;
                            tooltipContent += `Pace: ${Math.floor(runPace)}:${Math.round((runPace % 1) * 60).toString().padStart(2, '0')}/km<br/>`;
                            tooltipContent += `Segment Rank: ${athlete.athlete.runSegmentRank}<br/>`;
                            tooltipContent += `Percentile: ${percentile}%<br/>`;
                            tooltipContent += `Behind Leader: ${timeBehindLeader === 0 ? 'Leader' : '+' + secondsToTime(timeBehindLeader)}`;  
                        } else if (point.stage === 'T1' && athlete.athlete.actualT1Time) {
                            const allT1Times = processedData.map(a => a.actualT1Time).filter(t => t && t < 99 * 3600);
                            const percentile = getPercentile(athlete.athlete.actualT1Time, allT1Times);
                            
                            tooltipContent += `<strong>End of T1</strong><br/>`;
                            tooltipContent += `Time: ${secondsToTime(athlete.athlete.actualT1Time)}<br/>`;
                            tooltipContent += `Segment Rank: ${athlete.athlete.t1SegmentRank}<br/>`;
                            tooltipContent += `Percentile: ${percentile}%<br/>`;
                            tooltipContent += `Behind Leader: ${timeBehindLeader === 0 ? 'Leader' : '+' + secondsToTime(timeBehindLeader)}`;
                            
                        } else if (point.stage === 'T2' && athlete.athlete.actualT2Time) {
                            const allT2Times = processedData.map(a => a.actualT2Time).filter(t => t && t < 99 * 3600);
                            const percentile = getPercentile(athlete.athlete.actualT2Time, allT2Times);
                            
                            tooltipContent += `<strong>End of T2</strong><br/>`;
                            tooltipContent += `Time: ${secondsToTime(athlete.athlete.actualT2Time)}<br/>`;
                            tooltipContent += `Segment Rank: ${athlete.athlete.t2SegmentRank}<br/>`;
                            tooltipContent += `Percentile: ${percentile}%<br/>`;
                            tooltipContent += `Behind Leader: ${timeBehindLeader === 0 ? 'Leader' : '+' + secondsToTime(timeBehindLeader)}`;
                            
                        }

                        tooltipContent += `<br/><br/><em style="font-size: 10px;">Long press for hypothetical analysis</em>`;
                        
                        const isNearRightEdge = point.stage === 'Finish' || 
                                            currentXScale(point.distance) > chartWidth * 0.8;
                        
                        if (isNearRightEdge) {
                            // Position tooltip to the left
                            tooltip.html(tooltipContent)
                                .style("left", (event.pageX - 220) + "px")  // 220px = typical tooltip width + margin
                                .style("top", (event.pageY - 28) + "px");
                        } else {
                            // Position tooltip to the right (default)
                            tooltip.html(tooltipContent)
                                .style("left", (event.pageX + 10) + "px")
                                .style("top", (event.pageY - 28) + "px");
                        }
                    })
                    .on("mouseout", function() {
                        d3.selectAll(`.athlete-path-${athlete.athleteIndex}`)
                            .attr("stroke-width", 1.5)
                            .attr("opacity", 0.4);
                        d3.select(this).attr("r", 4);
                        d3.select("#tooltip").transition()
                            .duration(500)
                            .style("opacity", 0);
                    });
                });                
            });
            drawTeamHighlights();
        }

        function updateDevelopmentChart() {
            if (!currentXScale || !currentYScale || !developmentChartData) return;
            
            if (currentSection !== 'zoom') {
                const bounds = sectionBounds[currentSection];
                if (!bounds) return;
                
                currentXScale.domain([bounds.start, bounds.end]);
            
                let relevantData = [];
                developmentChartData.forEach(athlete => {
                    if (developmentAthleteVisibility[athlete.name]) {
                        athlete.values.forEach(point => {
                            if (point.distance >= bounds.start && point.distance <= bounds.end) {
                                relevantData.push(point.timeBehind);
                            }
                        });
                    }
                });
            
                const minTime = d3.min(relevantData) || 0;
                const maxTime = d3.max(relevantData) || 0;
                currentYScale.domain([-(maxTime + 5), Math.max(10, -minTime + 5)]);
            }
            
            // Update axes and grids
            developmentG.select(".x-axis")
                .transition()
                .duration(750)
                .call(d3.axisBottom(currentXScale).tickFormat(""));
            
            // Update labels based on section
            if (currentSection === 'all') {
                developmentG.selectAll(".x-labels text").style("display", "block");
                developmentG.select(".x-axis-label").text("Race Progress");
            } else {
                developmentG.selectAll(".x-labels text").style("display", "none");
                
                let leader, time, section;
                switch(currentSection) {
                    case 'swim':
                        leader = segmentLeaders.swim;
                        time = leader.actualSwimTime;
                        section = 'Swim';
                        break;
                    case 't1':
                        leader = segmentLeaders.t1;
                        time = leader.actualT1Time;
                        section = 'T1';
                        break;
                    case 'bike':
                        leader = segmentLeaders.bike;
                        time = leader.actualBikeTime;
                        section = 'Bike';
                        break;
                    case 't2':
                        leader = segmentLeaders.t2;
                        time = leader.actualT2Time;
                        section = 'T2';
                        break;
                    case 'run':
                        leader = segmentLeaders.run;
                        time = leader.actualRunTime;
                        section = 'Run';
                        break;
                }
                
                if (currentSection !== 'zoom' && leader) {
                    developmentG.select(".x-axis-label")
                        .html(`${section} Progress - Leader: <tspan fill="${colorScale(leader.name)}">${leader.name.split(' ')[1]} (${secondsToTime(time)})</tspan>`);
                }
            }
            
            developmentG.select(".y-axis")
                .transition()
                .duration(750)
                .call(d3.axisLeft(currentYScale)
                    .tickFormat(d => {
                        const absD = Math.abs(d);
                        if (isMobile) {
                            const mins = Math.floor(absD / 60);
                            return mins.toString();
                        } else {
                            return secondsToTime(absD);
                        }
                    })
                    .ticks(isMobile ? 3 : undefined)
                );
            
            developmentG.select(".grid-x")
                .transition()
                .duration(750)
                .call(d3.axisBottom(currentXScale).tickSize(-chartHeight).tickFormat(""));
            
            developmentG.select(".grid-y")
                .transition()
                .duration(750)
                .call(d3.axisLeft(currentYScale).tickSize(-chartWidth).tickFormat(""));
            
            // Update transition lines
            const transitionLineUpdates = [
                { class: '.transition-line-t1-start', pos: stageDist.swim },
                { class: '.transition-line-t1-end', pos: stageDist.t1 },
                { class: '.transition-line-t2-start', pos: stageDist.bike },
                { class: '.transition-line-t2-end', pos: stageDist.t2 }
            ];
            
            transitionLineUpdates.forEach(trans => {
                developmentG.select(trans.class)
                    .transition()
                    .duration(750)
                    .attr("x1", currentXScale(trans.pos))
                    .attr("x2", currentXScale(trans.pos));
            });
            
            // Update line generator with current scales
            lineGenerator
                .x(d => currentXScale(d.distance))
                .y(d => currentYScale(-d.timeBehind));
            
            // Update visible paths
            developmentG.select(".chart-content").selectAll(".athlete-path")
                .transition()
                .duration(750)
                .attr("d", lineGenerator);
            
            // CRITICAL FIX: Also update the invisible hit areas with the same path data
            developmentG.select(".chart-content").selectAll(".athlete-path-hitarea")
                .transition()
                .duration(750)
                .attr("d", lineGenerator);
            
            // Update circles
            developmentG.select(".chart-content").selectAll(".athlete-circle")
                .transition()
                .duration(750)
                .attr("cx", function() {
                    const x = parseFloat(d3.select(this).attr("data-x"));
                    return currentXScale(x);
                })
                .attr("cy", function() {
                    const y = parseFloat(d3.select(this).attr("data-y"));
                    return currentYScale(y);
                });
                
            drawTeamHighlights();
        }        

        function drawSpiderChart(data) {
            d3.select("#spiderChart").selectAll("*").remove();
            
            processedData.forEach((athlete, i) => {
                spiderAthleteVisibility[athlete.name] = athlete.finalRank && 
                                                         athlete.finalRank <= 5 && 
                                                         !['DNF', 'LAP', 'DSQ'].includes(athlete.status);
            });
            
            updateSpiderChart();
        }
        
        function updateSpiderChart() {
            if (!processedData) return;

            // Clear the container completely
            const spiderContainer = document.getElementById("spiderChart");
            spiderContainer.innerHTML = "";
            
            // Force centering styles
            spiderContainer.setAttribute('style', 
                'display: flex !important; ' +
                'justify-content: center !important; ' +
                'align-items: center !important; ' +
                'min-height: 500px !important;'
            );
            
            const filteredData = processedData;
            
            const { width, height, margin } = chartConfig.getDimensions('spiderChart', 'spider');
            const radius = Math.min(width, height) / 2;
            
            // Create SVG directly without any wrappers
            const svg = d3.select("#spiderChart")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .style("display", "block")
                .style("margin", "0 auto");
            
            const g = svg.append("g")
                .attr("transform", `translate(${(width + margin.left + margin.right)/2},${(height + margin.top + margin.bottom)/2})`);
                    
            const axes = [
                {axis: "Swim", key: "swimTime", rankKey: "swimSegmentRank"},
                {axis: "T1", key: "t1Time", rankKey: "t1SegmentRank"},
                {axis: "Bike", key: "bikeTime", rankKey: "bikeSegmentRank"},
                {axis: "T2", key: "t2Time", rankKey: "t2SegmentRank"},
                {axis: "Run", key: "runTime", rankKey: "runSegmentRank"}
            ];
            
            const percentiles = {};
            axes.forEach(ax => {
                const actualKey = ax.key.replace('Time', 'Time').replace('swim', 'actualSwim').replace('t1', 'actualT1')
                    .replace('bike', 'actualBike').replace('t2', 'actualT2').replace('run', 'actualRun');
                const values = filteredData
                    .filter(d => {
                        if (d.status === 'DSQ') return false;
                        const val = actualKey.includes('actual') ? 
                            d[actualKey] : d[ax.key];
                        return val && val < 99 * 3600;
                    })
                    .map(d => actualKey.includes('actual') ? d[actualKey] : d[ax.key])
                    .sort((a, b) => a - b);
                
                percentiles[ax.key] = {
                    min: values[0] || 0,
                    max: values[values.length - 1] || 1,
                    best: values[0] || 0,
                    worst: values[values.length - 1] || 1
                };
            });
            
            const rScale = d3.scaleLinear()
                .domain([0, 1.2])
                .range([0, radius * 1.2]);
            
            const angleSlice = Math.PI * 2 / axes.length;
            
            const levels = 5;
            for (let level = 0; level < levels; level++) {
                g.append("circle")
                    .attr("r", radius * ((level + 1) / levels))
                    .style("fill", "none")
                    .style("stroke", "#CDCDCD")
                    .style("stroke-opacity", 0.5);
            }
            
            const axis = g.selectAll(".axis")
                .data(axes)
                .enter()
                .append("g")
                .attr("class", "axis");
            
            axis.append("line")
                .attr("x1", 0)
                .attr("y1", 0)
                .attr("x2", (d, i) => rScale(1) * Math.cos(angleSlice * i - Math.PI / 2))
                .attr("y2", (d, i) => rScale(1) * Math.sin(angleSlice * i - Math.PI / 2))
                .style("stroke", "#CDCDCD")
                .style("stroke-width", "1px");
            
            axis.append("text")
                .attr("class", "axis-label")
                .attr("dy", "0.35em")
                .attr("x", (d, i) => rScale(1.15) * Math.cos(angleSlice * i - Math.PI / 2))
                .attr("y", (d, i) => rScale(1.15) * Math.sin(angleSlice * i - Math.PI / 2))
                .style("text-anchor", "middle")
                .text(d => d.axis);
            
            const radarData = filteredData.map(athlete => {
                return {
                    athlete: athlete,
                    values: axes.map(ax => {
                        let actualValue;
                        if (ax.key === 'swimTime') actualValue = athlete.actualSwimTime;
                        else if (ax.key === 't1Time') actualValue = athlete.actualT1Time;
                        else if (ax.key === 'bikeTime') actualValue = athlete.actualBikeTime;
                        else if (ax.key === 't2Time') actualValue = athlete.actualT2Time;
                        else if (ax.key === 'runTime') actualValue = athlete.actualRunTime;
                        
                        if (!actualValue || actualValue >= 99 * 3600) {
                            return {
                                axis: ax.axis,
                                value: 0,
                                rank: null,
                                incomplete: true
                            };
                        }
                        
                        const normalized = 1 - (actualValue - percentiles[ax.key].best) / 
                                              (percentiles[ax.key].worst - percentiles[ax.key].best);
                        return {
                            axis: ax.axis,
                            value: normalized,
                            rank: athlete[ax.rankKey],
                            incomplete: false
                        };
                    })
                };
            });
            
            const radarLine = d3.lineRadial()
                .radius(d => rScale(d.value))
                .angle((d, i) => i * angleSlice)
                .curve(d3.curveLinearClosed);
            
            filteredData.forEach((athlete, athleteIndex) => {
                const athleteData = radarData[athleteIndex].values;
                
                let strokeDasharray = "";
                if (athlete.status === 'DSQ') {
                    strokeDasharray = "3,3";
                } else if (athlete.status === 'DNF' || athlete.status === 'LAP') {
                    strokeDasharray = "8,4";
                }
                
                const hasData = athleteData.some(d => !d.incomplete);
                if (hasData) {
                    const pathData = athleteData.map((d, i) => {
                        if (d.incomplete) {
                            return { value: 0 };
                        }
                        return d;
                    });
                    
                    const isVisible = spiderAthleteVisibility[athlete.name] === true;
                    
                    g.append("path")
                        .datum(pathData)
                        .attr("class", `radar-area radar-area-${athleteIndex}`)
                        .attr("d", radarLine)
                        .style("fill", colorScale(athlete.name))
                        .style("stroke", colorScale(athlete.name))
                        .style("stroke-dasharray", strokeDasharray)
                        .classed("hidden", !isVisible);
                }
                
                if (hasData) {
                    d3.select(`.radar-area-${athleteIndex}`)
                    .on("mouseover", function(event) {
                        if (!spiderAthleteVisibility[athlete.name]) return;
                        
                        d3.select(this)
                            .style("fill-opacity", 0.4)
                            .style("stroke-width", 3);
                        
                        const tooltip = d3.select("#tooltip");
                        tooltip.transition().duration(200).style("opacity", .9);
                        
                        const athleteName = athlete.baseName || athlete.name.replace(/ \([^)]*\)$/, '');
                        let tooltipContent = `<strong>${athleteName} ${athlete.country}</strong><br/>`;
                        
                        if (athlete.actualSwimTime) {
                            const swimPace = (athlete.actualSwimTime / raceConfig.swim) * 100;
                            tooltipContent += `Swim: ${secondsToTime(athlete.actualSwimTime)} (${secondsToTime(swimPace)}/100m) - Rank ${athlete.swimSegmentRank || 'N/A'}<br/>`;
                        }
                        if (athlete.actualT1Time) {
                            tooltipContent += `T1: ${secondsToTime(athlete.actualT1Time)} (${athlete.t1SegmentRank || 'N/A'})<br/>`;
                        }
                        if (athlete.actualBikeTime) {
                            const bikeSpeed = (raceConfig.bike / (athlete.actualBikeTime / 3600)).toFixed(1);
                            tooltipContent += `Bike: ${secondsToTime(athlete.actualBikeTime)} (${bikeSpeed} km/hr) - Rank ${athlete.bikeSegmentRank || 'N/A'}<br/>`;
                        } else if (athlete.status === 'DNF' || athlete.status === 'LAP') {
                            tooltipContent += `Bike: DNF<br/>`;
                        }
                        if (athlete.actualT2Time) {
                            tooltipContent += `T2: ${secondsToTime(athlete.actualT2Time)} (${athlete.t2SegmentRank || 'N/A'})<br/>`;
                        }
                        if (athlete.actualRunTime) {
                            const runPace = athlete.actualRunTime / raceConfig.run / 60;
                            const paceStr = `${Math.floor(runPace)}:${Math.round((runPace % 1) * 60).toString().padStart(2, '0')}`;
                            tooltipContent += `Run: ${secondsToTime(athlete.actualRunTime)} (${paceStr}/km) - Rank ${athlete.runSegmentRank || 'N/A'}<br/>`;
                        } else if ((athlete.status === 'DNF' || athlete.status === 'LAP') && athlete.actualBikeTime) {
                            tooltipContent += `Run: DNF<br/>`;
                        }                        
                        if (athlete.status) {
                            tooltipContent += `<hr style="margin: 5px 0; border: 0; border-top: 1px solid rgba(255,255,255,0.3);">`;
                            tooltipContent += `Status: ${athlete.status}`;
                        } else {
                            const totalTime = athlete.actualTotalTime || 0;
                            tooltipContent += `<hr style="margin: 5px 0; border: 0; border-top: 1px solid rgba(255,255,255,0.3);">`;
                            tooltipContent += `Total: ${secondsToTime(totalTime)} (${athlete.position || athlete.finalRank})`;
                        }
                        
                        tooltip.html(tooltipContent)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function() {
                        if (!spiderAthleteVisibility[athlete.name]) return;
                        
                        d3.select(this)
                            .style("fill-opacity", 0.2)
                            .style("stroke-width", 2);
                        
                        d3.select("#tooltip").transition()
                            .duration(500)
                            .style("opacity", 0);
                    });
                }
                
                const dots = g.selectAll(`.radar-dots-${athleteIndex}`)
                    .data(athleteData.filter(d => !d.incomplete))
                    .enter()
                    .append("circle")
                    .attr("class", `radar-dots radar-dots-${athleteIndex}`)
                    .attr("cx", (d, i) => {
                        const actualIndex = axes.findIndex(ax => ax.axis === d.axis);
                        return rScale(d.value) * Math.cos(angleSlice * actualIndex - Math.PI / 2);
                    })
                    .attr("cy", (d, i) => {
                        const actualIndex = axes.findIndex(ax => ax.axis === d.axis);
                        return rScale(d.value) * Math.sin(angleSlice * actualIndex - Math.PI / 2);
                    })
                    .attr("r", 4)
                    .style("fill", colorScale(athlete.name))
                    .classed("hidden", !isVisible);
            });
        }
        
        function toggleIndividualAthlete(athleteName, athleteIndex) {
            developmentAthleteVisibility[athleteName] = !developmentAthleteVisibility[athleteName];
            const isVisible = developmentAthleteVisibility[athleteName];
            
            d3.selectAll(`.athlete-path-${athleteIndex}`).classed("hidden", !isVisible);
            d3.selectAll(`.athlete-path-hitarea-${athleteIndex}`).classed("hidden", !isVisible); // ADD THIS LINE
            d3.selectAll(`.athlete-circle-${athleteIndex}`).classed("hidden", !isVisible);
            
            updateDevelopmentChart();
            
            // Update button state
            event.target.classList.toggle('hidden', !isVisible);

        }
        
        function toggleIndividualSpiderAthlete(athleteName) {
            spiderAthleteVisibility[athleteName] = !spiderAthleteVisibility[athleteName];
            
            // Update button state
            event.target.classList.toggle('hidden', !spiderAthleteVisibility[athleteName]);
            
            updateSpiderChart();
        }
        // Calculate bike packs based on position at end of swim + T1
        function calculateBikePacks() {
            const athletesAtT1 = processedData
                .filter(a => a.actualT1Time)
                .map(a => ({
                    athlete: a,
                    t1Time: a.swimCumulative + a.actualT1Time
                }))
                .sort((a, b) => a.t1Time - b.t1Time);
            
            // Define packs based on gaps (> 10 seconds = different pack)
            bikePacks = {
                lead: [],
                chase: [],
                dropped: []
            };
            
            if (athletesAtT1.length > 0) {
                let currentPack = [athletesAtT1[0]];
                let packs = [];
                
                for (let i = 1; i < athletesAtT1.length; i++) {
                    if (athletesAtT1[i].t1Time - athletesAtT1[i-1].t1Time > 10) {
                        packs.push([...currentPack]);
                        currentPack = [];
                    }
                    currentPack.push(athletesAtT1[i]);
                }
                if (currentPack.length > 0) packs.push(currentPack);
                
                // Assign to categories
                if (packs[0]) bikePacks.lead = packs[0];
                if (packs[1]) bikePacks.chase = packs[1];
                if (packs.length > 2) {
                    bikePacks.dropped = packs.slice(2).flat();
                }
            }
            
            return bikePacks;
        }
        function openHypotheticalDialog(athlete, stage) {
            hypotheticalAthlete = athlete;
            hypotheticalStage = stage;
            
            // Reset manual adjustment flag
            manualRunAdjustment = false;
            lastBikeStrategy = 'solo';
            
            calculateBikePacks();
            
            // Populate athlete info
            const athleteInfo = document.getElementById('athleteInfo');
            athleteInfo.innerHTML = `
                <h4>${athlete.baseName || athlete.name} - ${athlete.country}</h4>
                <p>Current Position: ${athlete.finalRank || 'N/A'}</p>
                <p>Analyzing from: ${stage}</p>
            `;
            
            // Set initial pace info
            updatePaceInfo();
            
            // Show dialog
            document.getElementById('hypotheticalDialog').style.display = 'flex';
            
            // Initialize sliders and listeners
            initializeHypotheticalControls();
        }

        function closeHypotheticalDialog() {
            document.getElementById('hypotheticalDialog').style.display = 'none';
            // Reset sliders and manual override flag
            document.querySelectorAll('.scenario-controls input[type="range"]').forEach(input => {
                input.value = 0;
            });
            manualRunOverride = false;
            updateHypotheticalVisualization();
        }
        function initializeHypotheticalControls() {
            // Swim adjustment
            const swimAdjust = document.getElementById('swimAdjust');
            swimAdjust.addEventListener('input', function() {
                document.getElementById('swimAdjustValue').textContent = `${this.value}%`;
                updatePaceInfo();
                updateScenarioResults();
            });
            
            // T1 adjustment
            const t1Adjust = document.getElementById('t1Adjust');
            t1Adjust.addEventListener('input', function() {
                document.getElementById('t1AdjustValue').textContent = `${this.value}s`;
                updateScenarioResults();
            });
            
            // Bike strategy
            const bikeStrategy = document.getElementById('bikeStrategy');
            bikeStrategy.addEventListener('change', function() {
                const customControl = document.getElementById('bikeCustomControl');
                if (this.value === 'custom') {
                    customControl.style.display = 'block';
                } else {
                    customControl.style.display = 'none';
                }
                
                // If user hasn't manually adjusted run, apply bike strategy impact
                if (!manualRunAdjustment) {
                    applyBikeStrategyToRun(this.value);
                }
                
                lastBikeStrategy = this.value;
                updateBikeProjection();
                updateRunImpact();
                updateScenarioResults();
            });
            
            // Bike custom adjustment
            const bikeAdjust = document.getElementById('bikeAdjust');
            if (bikeAdjust) {
                bikeAdjust.addEventListener('input', function() {
                    document.getElementById('bikeAdjustValue').textContent = `${this.value}%`;
                    updateBikeProjection();
                    if (!manualRunAdjustment) {
                        applyBikeStrategyToRun('custom');
                    }
                    updateRunImpact();
                    updateScenarioResults();
                });
            }
            
            // Run adjustment - with manual override tracking
            const runAdjust = document.getElementById('runAdjust');
            runAdjust.addEventListener('input', function() {
                document.getElementById('runAdjustValue').textContent = `${this.value}%`;
                manualRunAdjustment = true; // User has manually adjusted
                updateRunImpact();
                updateScenarioResults();
            });
            
            // Add a reset button to clear manual override
            const runControlGroup = runAdjust.closest('.control-group');
            if (!document.getElementById('resetRunAdjust')) {
                const resetBtn = document.createElement('button');
                resetBtn.id = 'resetRunAdjust';
                resetBtn.className = 'btn';
                resetBtn.textContent = 'Reset to Auto';
                resetBtn.style.marginTop = '5px';
                resetBtn.onclick = function() {
                    manualRunAdjustment = false;
                    applyBikeStrategyToRun(lastBikeStrategy);
                    updateRunImpact();
                    updateScenarioResults();
                };
                runControlGroup.appendChild(resetBtn);
            }
            
            // Initial update
            manualRunAdjustment = false;
            lastBikeStrategy = 'solo';
            updateScenarioResults();
            updateHypotheticalVisualization();
        }

        function applyBikeStrategyToRun(strategy) {
            const runSlider = document.getElementById('runAdjust');
            let suggestedAdjustment = 0;
            
            switch(strategy) {
                case 'solo':
                    suggestedAdjustment = -10; // Suggest 10% slower
                    break;
                case 'leadPack':
                    suggestedAdjustment = -5; // Suggest 5% slower
                    break;
                case 'chasePack':
                    suggestedAdjustment = 0; // No impact
                    break;
                case 'custom':
                    const bikeAdjust = parseFloat(document.getElementById('bikeAdjust')?.value || 0);
                    if (bikeAdjust > 0) {
                        // Faster bike suggests slower run
                        suggestedAdjustment = -(bikeAdjust * 0.5);
                    }
                    break;
            }
            
            runSlider.value = suggestedAdjustment;
            document.getElementById('runAdjustValue').textContent = `${suggestedAdjustment}%`;
        }

function updateScenarioResults() {
            // Calculate hypothetical times
            const swimAdjust = parseFloat(document.getElementById('swimAdjust').value) / 100;
            const t1Adjust = parseFloat(document.getElementById('t1Adjust').value);
            const bikeProjection = updateBikeProjection();
            const t2Adjust = parseFloat(document.getElementById('t2Adjust').value);
            const runAdjust = parseFloat(document.getElementById('runAdjust').value) / 100;
            
            // Simple calculation - use slider value directly (user has full control)
            const hypothetical = {
                swim: hypotheticalAthlete.actualSwimTime * (1 - swimAdjust),
                t1: Math.max(0, hypotheticalAthlete.actualT1Time - t1Adjust),
                bike: bikeProjection.time,
                t2: Math.max(0, hypotheticalAthlete.actualT2Time - t2Adjust),
                run: hypotheticalAthlete.actualRunTime * (1 - runAdjust) // Direct application of slider
            };
            
            const hypotheticalTotal = hypothetical.swim + hypothetical.t1 + 
                                    hypothetical.bike + hypothetical.t2 + hypothetical.run;
            
            // Calculate new position
            const newPosition = processedData.filter(a => 
                a.actualTotalTime && a.actualTotalTime < hypotheticalTotal
            ).length + 1;
            
            // Display comparison
            const comparison = document.getElementById('scenarioComparison');
            comparison.innerHTML = `
                <div class="comparison-column">
                    <h5>Actual Performance</h5>
                    <div class="comparison-item">
                        <span>Total Time:</span>
                        <strong>${secondsToTime(hypotheticalAthlete.actualTotalTime)}</strong>
                    </div>
                    <div class="comparison-item">
                        <span>Position:</span>
                        <strong>${hypotheticalAthlete.finalRank}</strong>
                    </div>
                    <div class="comparison-item">
                        <span>Swim:</span>
                        <span>${secondsToTime(hypotheticalAthlete.actualSwimTime)}</span>
                    </div>
                    <div class="comparison-item">
                        <span>Bike:</span>
                        <span>${secondsToTime(hypotheticalAthlete.actualBikeTime)}</span>
                    </div>
                    <div class="comparison-item">
                        <span>Run:</span>
                        <span>${secondsToTime(hypotheticalAthlete.actualRunTime)}</span>
                    </div>
                </div>
                <div class="comparison-column">
                    <h5>Hypothetical Performance</h5>
                    <div class="comparison-item">
                        <span>Total Time:</span>
                        <strong>${secondsToTime(hypotheticalTotal)}</strong>
                    </div>
                    <div class="comparison-item">
                        <span>Position:</span>
                        <strong>${newPosition}</strong>
                    </div>
                    <div class="comparison-item">
                        <span>Swim:</span>
                        <span>${secondsToTime(hypothetical.swim)}</span>
                    </div>
                    <div class="comparison-item">
                        <span>Bike:</span>
                        <span>${secondsToTime(hypothetical.bike)}</span>
                    </div>
                    <div class="comparison-item">
                        <span>Run:</span>
                        <span>${secondsToTime(hypothetical.run)}</span>
                    </div>
                </div>
            `;
            
            updateHypotheticalVisualization(hypothetical);
        }
                
        function updateBikeProjection() {
            const strategy = document.getElementById('bikeStrategy').value;
            const bikePaceInfo = document.getElementById('bikePaceInfo');
            
            let projectedBikeTime = hypotheticalAthlete.actualBikeTime;
            let effortLevel = 'Normal';
            
            switch(strategy) {
                case 'leadPack':
                    const leadPackAvg = d3.mean(bikePacks.lead.map(a => a.athlete.actualBikeTime));
                    projectedBikeTime = leadPackAvg || projectedBikeTime * 0.93;
                    effortLevel = 'High (rotating in pack)';
                    break;
                    
                case 'chasePack':
                    const chasePackAvg = d3.mean(bikePacks.chase.map(a => a.athlete.actualBikeTime));
                    projectedBikeTime = chasePackAvg || projectedBikeTime * 0.97;
                    effortLevel = 'Moderate (drafting benefit)';
                    break;
                    
                case 'solo':
                    effortLevel = 'Very High (no draft)';
                    break;
                    
                case 'custom':
                    const bikeAdjust = parseFloat(document.getElementById('bikeAdjust').value) / 100;
                    projectedBikeTime = hypotheticalAthlete.actualBikeTime * (1 - bikeAdjust);
                    effortLevel = 'Custom';
                    break;
            }
            
            const bikeSpeed = (raceConfig.bike / (projectedBikeTime / 3600)).toFixed(1);
            const actualSpeed = (raceConfig.bike / (hypotheticalAthlete.actualBikeTime / 3600)).toFixed(1);
            
            bikePaceInfo.innerHTML = `
                Time: ${secondsToTime(hypotheticalAthlete.actualBikeTime)} ‚Üí ${secondsToTime(projectedBikeTime)}<br/>
                Speed: ${actualSpeed} km/hr ‚Üí ${bikeSpeed} km/hr<br/>
                Effort: ${effortLevel}
            `;
            
            return { time: projectedBikeTime, effort: effortLevel };
        }


        function updateRunImpact() {
            const bikeStrategy = document.getElementById('bikeStrategy').value;
            const runAdjust = parseFloat(document.getElementById('runAdjust').value);
            const warning = document.getElementById('runEffortWarning');
            
            // Show warning about typical effects, but don't force them
            if (!manualRunAdjustment) {
                switch(bikeStrategy) {
                    case 'solo':
                        warning.innerHTML = '‚ö†Ô∏è Solo bike effort typically slows run by ~10% (auto-adjusted)';
                        warning.classList.add('active');
                        break;
                    case 'leadPack':
                        warning.innerHTML = '‚ö†Ô∏è Lead pack work typically slows run by ~5% (auto-adjusted)';
                        warning.classList.add('active');
                        break;
                    default:
                        warning.classList.remove('active');
                }
            } else {
                warning.innerHTML = '‚úì Manual run adjustment active (overriding bike strategy effects)';
                warning.style.background = '#d1ecf1';
                warning.classList.add('active');
            }
            
            const runPaceInfo = document.getElementById('runPaceInfo');
            
            const baseRunTime = hypotheticalAthlete.actualRunTime;
            const adjustedRunTime = baseRunTime * (1 - runAdjust / 100);
            
            const baseRunPace = baseRunTime / raceConfig.run / 60; // min/km
            const adjustedPace = adjustedRunTime / raceConfig.run / 60; // min/km
            
            const formatPace = (pace) => {
                return `${Math.floor(pace)}:${Math.round((pace % 1) * 60).toString().padStart(2, '0')}`;
            };
            
            runPaceInfo.innerHTML = `
                Time: ${secondsToTime(baseRunTime)} ‚Üí ${secondsToTime(adjustedRunTime)}<br/>
                Pace: ${formatPace(baseRunPace)}/km ‚Üí ${formatPace(adjustedPace)}/km
            `;
        }


        function updatePaceInfo() {
            const swimAdjust = parseFloat(document.getElementById('swimAdjust').value) / 100;
            const swimPaceInfo = document.getElementById('swimPaceInfo');
            
            const baseSwimPace = (hypotheticalAthlete.actualSwimTime / raceConfig.swim) * 100; // per 100m
            const adjustedSwimPace = baseSwimPace * (1 - swimAdjust);
            
            const baseSwimTime = hypotheticalAthlete.actualSwimTime;
            const adjustedSwimTime = baseSwimTime * (1 - swimAdjust);
            
            swimPaceInfo.innerHTML = `
                Time: ${secondsToTime(baseSwimTime)} ‚Üí ${secondsToTime(adjustedSwimTime)}<br/>
                Pace: ${secondsToTime(baseSwimPace)}/100m ‚Üí ${secondsToTime(adjustedSwimPace)}/100m
            `;
        }



        function updateHypotheticalVisualization(hypothetical) {
            // This would create a mini version of the development chart
            // showing the actual vs hypothetical trajectories
            // Implementation would be similar to the main development chart
            // but with two lines - one for actual, one for hypothetical
        }        
    </script>
</body>
</html>